## Synchronized

### 可重入性

问题：有一个线程访问某个对象的synchronized修饰的方法或代码区域时，该线程则获取这个对象的锁，其他线程不能再调用该对象被synchronized影响的任何方法。那么，如果这个线程自己调用该对象的其他synchronized方法，Java是如何判定的？

——这个问题就是可重入性；

synchronized是可重入锁，问题中的答案是可以调用的，锁内部有一个计数器，每次被线程获取时，其内部计数器会加1 ，其他线程请求时，会等待。当为0时，其他线程就可以获取到这个锁。

其用处就是避免死锁，

### 状态不可知

对比lock 类，其状态不可知，不知道现在锁现在是否是可获取到；

### 非公平锁

所谓公平与否就是新来的线程在获取当前锁的概率情况，公平锁、非公平锁内部维护了一个双向链表，每个结点就是获取当前锁的线程，公平锁就是这些线程会排序，前面的线程会先于后面的线程获取到锁，非公平就是不一定会准守他们队列的顺序；ReentrantLock 锁可以实现公平与非公平锁。

### 偏向锁

由于大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。

### 乐观锁/悲观锁

**悲观锁**总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁；

悲观锁机制存在以下问题：　　

1. 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。

2. 一个线程持有锁会导致其它所有需要此锁的线程挂起。

**乐观锁**假设认为数据一般情况下不会产生并发冲突，所以在数据进行提交更新的时候，才会正式对数据是否产生并发冲突进行检测，如果发现并发冲突了，则让返回用户错误的信息，让用户决定如何去做。

### CAS 机制

CAS是英文单词**Compare And Swap**的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

更新一个变量的时候，只有当==变量的预期值A和内存地址V当中的实际值相同==时，才会将内存地址V对应的值修改为B。

举例：两个线程同时修改变量T的值（T =1在内存V），这时候a b两个线程去修改T的值，假设a 线程先于b线程执行，T 的值被改为2，这时候b再去修改T的值，但是在b的预期值为1，而此时内存里面的值为2，预期值和内存值不相等，就不去修改；这时候线程b会自旋再次操作。

这种机制就是CAS 机制。

> 从思想上来说，Synchronized属于**悲观锁**，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于**乐观锁**，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

**优点：**

Synchronized关键字会让没有得到锁资源的线程进入**BLOCKED**状态，而后在争夺到锁资源后恢复为**RUNNABLE**状态，这个过程中涉及到操作系统**用户模式**和**内核模式**的转换，代价比较高。所以在特定情况下，性能好于Synchronized。

**CAS的缺点：**

**1.CPU开销较大**

在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

**2.不能保证代码块的原子性** （这一点相对好理解一些）

CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

#### CAS 实现原理

分析AtomicXX 类，知道volivate 关键字和 unsafe 类来实现的，具体实现如下：

```
public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}
private volatile int value; //用volatile关键字来保证获得的当前值是内存中的最新值
public final int get() { //这个方法的作用是获取变量的当前值。
    return value;
}
```

```
这段代码是一个无限循环，也就是CAS的自旋。循环体当中做了三件事：
1.获取当前值。
2.当前值+1，计算出目标值。
3.进行CAS操作，如果成功则跳出循环，如果失败则重复上述步骤。
```

看一下 compareAndSet 方法

![image-20200716175420145](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggsyp87lsnj312y0iy126.jpg)

**unsafe为我们提供了**硬件级别的原子操作**。valueOffset**  代表对象的内存地址；expect 就是期望值，update 就是更新后的值；这就是CAS机制。

#### ABA 问题

[点击](https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg)



### ThreadLocal 

ThreadLocal是并发场景下用来解决变量共享问题的类，它能使原本线程间共享的对象进行线程隔离，即一个对象只对一个线程可见。如何实现的呢？

很简单，把每个线程放一个map 用来存储k-v 值不就行了，实际上，也确实是这样做的。比如 线程类thread 有一个变量 ThreadLocals。

```
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

然后这个ThreadLocalMap 是一个静态内部类 ，这个类有一个Entry用来存储数据的，类似于hashMap的Node。key 就是当前线程，value 是要存储的类型。





