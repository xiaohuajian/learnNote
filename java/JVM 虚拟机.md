# Java 内存区域和内存溢出

## 运行时数据区域

![image-20200627213901702](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg76f6p852j31400u04qp.jpg)

1 程序计数器 ：当前线程所执行的字节码行号执行器。线程私有，不会发生oom

2 java 虚拟机栈：

- 线程同步且私有的；

- 存放局部变量，和方法相关的信息；
- 当线程请求栈深度大于虚拟机啊所允许的深度，抛出stackoverflow ；如果内存用完内存，抛出OOM

3 本地native方法栈：执行c 代码的栈

4 java堆

	- 线程共享
	- 存放对象实例
	- GC回收的对象

5 方法区

- 线程共享
- 存放类加载的信息、运行时常量
- 内部不够，oom



java 中有一个原则：栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者方法区的常量池中（字符串常量对象存放在常量池中。）即ascii 码的 -128 -127 ；

那类中定义一个 i = 1；方法中定义一个j=2 ；i 和 j存放在哪？ 

一个方法中的变量名和变量值（这是两个概念）一般都是存在方法栈的本地变量数组中，==有一种情况就是当变量的值为-128~127时，变量的值不会新建内存而是直接引用方法区常量池中的值；==

在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。
（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中
（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。

二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。
同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量
（1）当声明的是基本类型的变量其变量名及其值放在堆内存中的
（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中.

> 假如说**方法内** i = 2 和 i = new Integer(2) ; 这两种表现是不一样的，i = 2 会直接去方法区的常量池中寻找，没有就创建；而 第二种会先创建一个对象，对象放在堆，其引用在方法栈。

题目：

```

public void test(){
		int i = 1;
		Integer i1 = new Integer(1)
		sout (i == i1) // true , 他们的内存都会指向第一次创建 1 的那个值 
		
		Integer a = new Integer (200);
		Integer b = new Integer (200);
		sout（a == b） // false
		
		关于字符串的可以看IDEA 里面的demo
}
```



# GC

gc就是垃圾回收器，要完成以下事情：

- 哪些内存要回收？
- 什么时候回收？
- 如恶化回收？

## 对象已死吗？

1 . 引用计数法：给对象添加一个计数器，有其他地方引用的话加1，引用失效时候减1.当为0就判断器是不在能使用的。**缺点：无法解决循环引用的问题**

2 可达性分析：以GC root 为起点，向下搜索，搜索走过的路径称为 引用链。当其无法达到这个对象时，就判断其可回收。



## 引用类型

强引用：

软引用：在内存不够的时候去回收

弱引用：下次gc时，一定会回收

虚引用：不咋用

## 回收算法

标记-清除：把要回收的对象标记出来，在进行清除；缺点：得到大片不连续的空间；

标记-整理：把所有存活的对象一边去，然后清理掉边界以外的内存；

复制：把可使用的空间分为两块，使用其中一块，然后回收时把活着的对象复制到另一块，然后清理掉已使用的空间。

分代：根据对象的存活周期的不同将内存划分为几块；新生代、老年代、永久代；针对不同的年代采用各自适合的回收方法达到效率最优，它本质没有产生新的回收算法，只不过根据对象不同的特点采用不同的回收算法。

### 回收器类型

- serial GC 顺序执行
- Par GC ：并发执行
- CMS：标记-整理



# 类加载机制

启动类加载器Bootstrap classloader ，c++实现的，另一种加载器是其他加载器，由java 语言实现，继承classloader；

双亲委派模型：除了顶层的启动类加载器外，其余的类加载器都应当有自己的父加载器类。一个类加载器收到了加载的请求，它自己不会先去加载，而是给父亲加载，每一层都是如此，最终会传到顶层的启动加载器总，只有当父类无法加载这个类时，子类才会去加载。

优点：

试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的 String 来动态替代 java 核心 api 中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况。

**因为 String 已经在 启动时就被引导类加载器（BootstrcpClassLoader）加载，所以用户自定义的ClassLoader 永远也无法加载一个自己写的 String，除非你改变 JDK 中ClassLoader 搜索类的默认算法。**



![image-20200627235503653](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg7acocx7gj30u01407wh.jpg)



另外，Android程序会把class文件打包成dex，所以android 有一个自己的类加载器dexClassLoader。

### 类初始化时机

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列四种情况必须对类进行初始化：

- **遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时**，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：
  - 使用 new 关键字实例化对象的时候；
  - 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；
  - 以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；



除此之外，**所有引用类的方式都不会触发初始化，称为被动引用**。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。
  `System.out.println(SubClass.value); // value 字段在 SuperClass 中定义`
- 通过数组定义来引用类，不会触发此类的初始化。
  `SuperClass[] sca = new SuperClass[10]; `
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
  

### 类加载流程？

参考文章链接  知乎 沉默王二

 类加载分三大块：加载、连接、初始化

 <img src="https://img-blog.csdnimg.cn/20190415110942370.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbmd4aWFudGFvMTk5NA==,size_16,color_FFFFFF,t_70" alt="pic" style="zoom:75%;" />

1. 加载：查找并加载class文件

2. 连接分为验证、准备、解析：

   - 验证：确保被导入类型的正确性, 不会危害虚拟机；对文件格式、字节码引用验证

   - 准备：对类变量（静态变量）分配内存，并初始化 （对应数据类型的默认初始值，如 0， false，0L， null）。`

     > 注意：这里很关键，之前一直都理解错了，这里有两点：只对static 变量；二是初始化的值是数据类型的默认值，假如说
     >
     > public static int value = 2; 在准备阶段这时候value 是 0，不是2 。这一点一直都理解错了。
     >
     > 在看 `public static final int CONSTANT = 1;` 这个是**常量**，是在编译阶段就确定值了，并且无法改变。

   - 解析：将常量池内的符号引用替换为直接引用

     > 这个也不好理解，符号引用以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。
     >
     > 在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 com.Wanger 类引用了 com.Chenmo 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 com.Chenmo。
     >
     > 直接引用通过对符号引用进行解析，找到引用的实际内存地址。

3. 初始化：

   1. 对**类变量**赋予 期望的值，比如说 前面举例value 在准备阶段的值为0 ，现在会给其赋值为2. **（经常听到：静态变量在类加载过程就赋值了，前面的分析刚刚印证了这个说法）**
   2. 执行构造函数



### 比较两个类是否相等

对于任意一个类，**需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性**，或者 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

JVM 在判定两个 class 是否相同时，不仅要判断两个类名否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM 才认为这两个 class 是相同的。就算两个 class是同一份 class 字节码，如果被两个不同的 ClassLoader 实例所加载，JVM 也会认为它们是两个不同 class。



### 代码执行顺序

（静态）变量、（静态）代码块、构造函数、普通函数；然后父类、子类，他们这些混合到一起执行顺序是什么？

```
public class SubCodeExecuteOrder extends CodeExecuteOrder{

    public String var2 = "子类普通变量";

    public static String var1 = "子类静态变量";

    static {
        System.out.println("子类静态代码块");

        System.out.println(var1);

    }


    {
        System.out.println("子类代码块");
        System.out.println(var2); //如果不把var2 定义到代码块前面 会报异常
    }

    public SubCodeExecuteOrder(){
        System.out.println("子类构造函数");
    }

    public static void main(String[] args) {
        SubCodeExecuteOrder codeExecuteOrder = new SubCodeExecuteOrder();
    }
}

其父类和子类一样，内容都是一样的；
下面是输出内容：
//静态的
父类静态代码块
父类静态变量
子类静态代码块
子类静态变量

//父类的非静态
父类代码块
父类普通变量
父类构造函数

//子类的非静态
子类代码块
子类普通变量
子类构造函数

```

结论：

1. 父类的静态变量和代码块 （变量和代码块哪个写在前面哪个执行）

2. 子类的静态变量和代码块 （变量和代码块哪个写在前面哪个执行）

3. 父类的变量和代码块（变量和代码块哪个写在前面哪个执行）——> 构造函数

4. 子类的变量和代码块（变量和代码块哪个写在前面哪个执行）——> 构造函数