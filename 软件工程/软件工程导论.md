# 软件工程概述

## 软件危机

### 概念 

 软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。 

### 典型表现

 ①对软件开发成本和进度的估计不准确。 

 ②用户对“已完成的”软件系统不满意的现象经常发生。

 ③软件产品的质量往往靠不住。 

 ④软件常常是不可维护的。 

 ⑤软件通常没有适当的文档资料。

 ⑥软件成本在计算机系统总成本中所占的比例逐年上升。 

 ⑦软件开发跟不上计算机应用迅速普及深入的趋势。

  原因

①存在与软件开发和维护有关的许多错误认识和做法。 

②对用户要求没有完整准确的认识就匆忙着手编写程序。 

③开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）。 

④软件开发人员轻视维护。

## 软件工程

采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够 得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。

软件 = 程序 + 数据 + 文档 （这三者构成软件）

### 本质特征 

①软件工程关注于大型程序的构造； 

②软件工程的中心课题是控制复杂性； 

③软件经常变化；

 ④开发软件的效率非常重要； 

⑤和谐地合作是开发软件的关键； 

⑥软件必须有效地支持它的用户；

 ⑦软件工程领域由具有一种文化背景的人替具有另一种文化背景的人创造产品。



### 七条基本原理 

①用分阶段的生命周期计划严格管理； 

②坚持进行阶段评审； 

③实行严格的产品控制； 

④采用现代程序设计技术；

 ⑤结果应能清楚地审查； 

⑥开发小组的人员应该少而精；

 ⑦承认不断改进软件工程实践的必要性。

这七条原理是确保软件产品质量和开发效率的原理的最小集合，它们是互相独立的，而且是缺一不可的最小 集合，然而这七条原理又是相当完备的。

### 软件工程方法学

**概念** 

通常把软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为范型。目前使用得最广泛的 软件工程方法学，分别是传统方法学和面向对象方法学。就是理解为面向过程、面向对象。

## 软件生命周期

### 软件定义 

软件定义时期通常进一步划分成 3 个阶段，即问题定义、可行性研究和需求分析。 

- 问题定义： 解决的问题是啥。搞清问题性质、工程目标、工程规划。
- 可行性研究：研究问题范围，提出可行的解决办法
- 需求分析：确定系统具备哪些功能；（流程图、简要的算法表示模型）

### 软件开发 

通常由下述 4 个阶段组成：总体设计，详细设计，编码和单元测试，综合测试。其中**前两个阶段又称为系统设计，后两个阶段又称为系统实现。** 

- 总体设计（概要设计）：如何实现目标系统的功能，提出大致的几种方案（一种高成本、中成本、低成本），并描述各种方案的优缺点，并给出最佳方案。
- 详细设计：对概要设计中的最佳方案，进行详细说明，给出各个流程步骤及相应文档。（通过uml 建模说明设计细节）
- 编码和单元测试：给出正确、易维护的程序模块（是开发人员完成的任务）
- 综合测试：测试人员进行测试，分集成测试、验收测试。

### 软件维护

通过维护使系统持久的满足用户需求



## 软件过程

### 概念

（1）定义 软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。 

（2）表示 使用生命周期模型简洁地描述软件过程。

### 软件过程模型

#### 瀑布模型

属于传统软件工程方法学的软件过程方法。

**特点**

第一，阶段间具有顺序性和依赖性；（各阶段的工作有前后依赖关系）

第二，推迟实现的观点； （开发编码阶段往往靠后，不是在很前面）

第三，质量保证的观点。（其目的是保证软件质量高产，他是由文档驱动的，缺乏对于需求变更和项目变化的适应性。）



#### 快速原型模型

![image-20201103185417168](https://tva1.sinaimg.cn/large/0081Kckwgy1gkc6lh1y7hj30i00iwq5n.jpg)

以产品的主要需求为原型，然后快速开发和迭代。

#### 增量模型

![image-20201103185830224](https://tva1.sinaimg.cn/large/0081Kckwgy1gkc6pv95evj30mp0brmz2.jpg)

增量模型也称为渐增模型，把软件产品作为多个增量构件来设计、编码、集成、测试，开发人员一个构件接一个构件地向用户提交产品。

**优点**

能在较短时间内向用户提交可完成部分工作的产品。 b．逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。

**缺点**

a 要求软件体系结构必须是开放的。

b．增量模型本身是自相矛盾的。

c．增量模型的灵活性很容易退化为边做边改模型，从而使软件过程的控制失去整体性。

#### 敏捷开发

敏捷过程能够较好地适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。敏捷过程中最 重要的是极限编程。极限编程要求我们可以快速响应，同时敏捷要求我们灵活，所以有一些规则准守会让我们更好的做到敏捷。

- 个体交互胜过过程和工具 （团队人员的组建大于一切，让成员相互配合）
- 可以工作的软件胜过面面俱到的文档
- 客户合作胜过合同谈判
- 响应变化胜过遵循计划

极限编程的理念包含：

- 客户作为开发团队成员
- 短交付周期 
- 测试驱动开发 （编码之前要设计好测试用例）
- 重构 （经常优化代码、注重设计）

一些观念

- 持续集成 （一天之内多次提交成果）
- 可持续开发 （注重人员的劳逸结合）
- 及时调整 （响应变化）

微软准则

- 把零缺陷作为目标
- 里程碑的评审是改进工作，切忌相互指责
- 项目计划应兼顾未来不确定因素
- 项目进度具有相当的权威性
- 采用快速迭代开发
- 使用风险管理避免风险



# 可行性研究

## 目的

可行性分析是系统在正式立项之前必须进行的一项工作，它的**目的不是为了分析软件开发过程中的问题，也不是为了解决软件开发过程中可能存在的问题，而是确**==定软件系统是否有价值做、是否能够以尽可能小的代价在尽可能短的时间内解决问题==**。

具体而言，在可行性分析阶段，要确定软件的开发目标与总的要求，所以在做可行性分析的时候，一般需要考虑技术是否可行、经济效益是否可行、用户操作是否可行、法律与社会是否可行等。例如，对于一个超市商品价格查询系统而言，就需要调查顾客是否希望使用这样的软件，超市商品价格来源是哪里？技术上是否能够实现等？

可行性分析一般都由战略专家执行，该阶段的文档成果为《可行性分析报告》

执行步骤，可行性研究分析过程：

> 首先，进一步分析和澄清问题定义
> 然后，分析员应该导出系统的逻辑模型
> 最后，探索若干种可供选择的主要解法

然后从

- 技术可行性使用现有的技术能实现这个系统吗?
- 操作可行性系统的操作方式在这个用户组织内行得通吗?
- 经济可行性这个系统的经济效益能超过它的开发成本吗?

## 研究过程

整体而言，有下面8个过程

1. 复查系统规模和目标
2. 研究目前正在使用的系统
3. 导出新系统的高层逻辑模型
4. 进一步定义问题
5. 导出和评价供选择的解法
6. 推荐行动方针
7. 草拟开发计划书
8. 写文档提交审查

### 复查系统规模和目标

对问题定义阶段书写的关于规模和目标的报告书进一步复查确认，确保分析员正在解决的问题确实是要求他解决的问题。

### 研究目前正在使用的系统

现有的系统是信息的重要来源。仔细阅读分析现有系统的文档资料和使用手册，从中获取一些信息，但不应花费大量时间。

### 导出新系统的高层逻辑模型

优秀的设计过程通常是从现有的物理系统出发，导出现有系统的逻辑模型，再参考现有系统的逻辑模型，设想目标系统的逻辑模型

### 进一步定义问题

可行性研究的前4个步骤实质上构成一个循环。分析员定义问题，分析这个问题，导出一个试探性的解；在此基础上再次定义问题，再一次分析这个问题，修改这个解；继续这个循环过程，直到提出的逻辑模型完全符合系统目标。

### 导出和评价供选择的解法

分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的物理解法供比较和选择。依次从技术、操作、经济三方面去排除不可行方案，选择一个最优方案，并简述理由。并给出可行方案的工作量、时间、成本。

### 草拟开发计划

为推荐的方案草拟一份开发计划，除了制定工程进度表之外还应该估计对各类开发人员和各种资源的需要情况，应该指明什么时候使用以及使用多长时间。此外还应该估计系统生命周期每个阶段的成本。

### 书写文档提交审查

应该把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。

<u>**上面的这些东西很有用，看上去很虚，其实在用的时候非常具有指导性。当我们在去技术调研的时候，其实可以套用这个可行性研究流程，按照这个模版写出来的东西，一定惊呆你的同事。同时，这个东西不光可以用在技术研究上，也可以用在日常生活中，这个东西威力很大，看你领悟和实际使用。其中一些步骤可以酌情删减。**</u>



## 系统流程图

用图形符号以黑盒子形式描绘组成系统的每个部件(程序、文档、数据库、人工过程等)。

系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，==因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而不是程序流程图。==

![image-20201103225420182](https://tva1.sinaimg.cn/large/0081Kckwgy1gkcdj9i62oj31cc0su45k.jpg)



![image-20201103225452421](https://tva1.sinaimg.cn/large/0081Kckwgy1gkcdjt2lbij319m0u07ed.jpg)



这些掌握部分图的用法就可以了。注意这是系统流程图，表示系统部件（程序、文档、数据库、人工过程）的数据之间流动，和程序流程图符号类似，但不一样。所以它的层次应该是更高的，通俗易懂的，不是局限在某个流程上的。

面对复杂的系统时，一个比较好的方法是分层次地描绘这个系统。首先用一张高层次的系统流程图描绘系统总体概貌，表明系统的关键功能。然后分别把每个关键功能扩展到适当的详细程度，画在单独的一页纸上。这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。

## 成本/效益估算

常见的成本估算方式：

- 代码行技术

  根据代码来分析成本

- 任务分解技术

  任务分解技术最常用的办法是按开发阶段划分任务。典型环境下各个开发阶段需要使用的人力的百分比大致如下表所示:

  ![image-20201103230144136](https://tva1.sinaimg.cn/large/0081Kckwgy1gkcdqxy9tsj31as0bmgp0.jpg)

  **这个表其实也表示了编码阶段在整个生命周期范围内的比重占比，这也是瀑布模型过程中的软件生命周期资源占比，具有一定的参考价值**

- 自动估计成本技术

  根据历史数据来估算



# 需求分析

需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么”这个问题。它是软件开发成功的前提条件。

目前用于需求分析的结构化分析方法，都遵守下述准则：

- 必须理解并描述问题的信息域，根据这条准则应该建立数据模型。
- 必须定义软件应完成的功能，这条准则要求建立功能模型。
- 必须描述作为外部事件结果的软件行为，这条准则要求建立行为模型
- 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。



## 需求分析任务

### 确定对系统的综合要求

虽然功能需求是对软件系统的一项基本需求，但却并不是唯一的需求，比如安全、性能、稳定性等等都属于需求中的一种。通常对软件系统有下述几方面的综合要求

- 功能需求：系统必须完成的所有功能
- 性能需求：指定系统必须满足的定时约束或容量约束，比如响应速度；
- 靠性和可用性需求：稳定性
- 错误处理
- 接口设计需求
- 约束条件 ：需求方提出的系统在某方面的限制条件
- 将来可能提出的要求：应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。系统具备一定的拓展性

当我们在分析程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，**修正以前制定的开发计划**。

## 用户沟通获取需求的方法

### 访谈

访谈是最早开始使用的获取用户需求的技术，也是迄今为止仍然广泛使用的需求分析技术。访谈分为正式的和非正式的访谈。

在访问用户的过程中使用情景分析技术往往非常有效。所谓情景分析就是对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。

还有其他形式的获取需求方式，比如头脑风暴，开发和用户一起出需求原型在一起讨论什么的，不在于采用什么方式，应该关注需求获取效率。

## 分析建模与规格说明

### 分析建模

模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。模型由符号及组织这些符号的规则组成。比如UML建模就是一种建模方式。

为了描述复杂的系统，应从不同角度（模型）抽象出目标系统的特性**（数据模型、功能模型、行为模型）**。常用的建模方式会借助一些图形工具，常见的UML、层次结构图、数据流图、层次方框图等等

### 软件需求规格说明

软件需求规格说明是需求分析阶段得出的最主要的文档。

通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。

## 需求分析用的图形工具

### 层次方框图

层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构



![image-20201104101908762](https://tva1.sinaimg.cn/large/0081Kckwgy1gkcxbs8b7ej30le0eeabn.jpg)

描绘一家计算机公司全部产品的数据结构可以用上图 层次方框图表示。这家公司的产品由硬件、软件和服务3类产品组成，软件产品又分为系统软件和应用软件，系统软件又进一步分为操作系统、编译程序和软件工具等。

### Warnier 图

类似xmind 图，功能和层次结构图类似。

![image-20201104102041262](https://tva1.sinaimg.cn/large/0081Kckwgy1gkcxdec40ej30l60bbn19.jpg)

## 验证软件需求

需求分析阶段的工作结果是开发软件系统的重要基础，大量统计数字表明，软件系统中15%的错误起源于错误的需求。为了保证正确性，从下面4个方面去验证：

- 一致性：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
- 完整性：需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。
- 现实性：指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。
- 有效性：必须证明需求是正确有效的，确实能解决用户面对的问题。

### 验证一致性

当需求分析的结果是用自然语言书写的时候，除了靠人工技术审查验证软件系统规格说明书的正确性之外，目前还没有其他更好的“测试”方法。为了克服上述困难，人们提出了**形式化语言**（把描述语言引入数学符号，定性定量的描述）的描述软件需求的方法。

### 验证现实性

参照以往开发类似系统的经验，分析用现有的软、硬件技术实现目标系统的可能性。就是利用经验，凭直观感受

### 验证完整性及有效性

只有目标系统的用户才真正知道软件需求规格说明书是否完整、准确地描述了他们的需求。因此，检验需求的完整性，特别是证明系统确实满足用户的实际需要，只有在用户的密切合作下才能完成。这个验证通常只能靠后期反馈，版本迭代补充。



# 形式化说明技术

## 概念

形式化规范就是用一套基于明确定义的数学概念的符号来书写，并且通常伴随着支持性的解释（非形式化）语句。这些数学概念被用来定义符号的句法和语义，以及支持逻辑推理的证明规则。支持形式化符号的句法和语义规则应该定义如何明确地识别其结构和确定其含义。并且必须有证据表明矛盾不可能产生，支持符号的所有规则都有定义或者引用。

半形式化规范就是用一种受限制的句法语言来书写，并且通常伴随着支持性的解释（非形式化）语句。这里的受限制句法语言可以是一种带有受限制句子结构和具有特殊意义的关键字的自然语言，也可以是图表式的（如：数据流图、状态转换图、实体关系图、数据结构图、流程或程序结构图）。不论基于图表还是自然语言必须用一套规范来定义句法限制。

非形式化规范就是像散文一样用自然语言来书写。在这里使用自然语言作为任何普通口头语言（如：荷兰语、英语、法语、德语）中意思的沟通。非形式化规范不像常规语言的传统用法（如：文法和句法）一样受一些符号或特殊的限制。虽然没有符号限制，非形式化规范也要求为上下文中的术语定义其意思，除非作为常规用法已认可。

定义：

形式化（*formal*）：在完备数学概念基础上，采用具有确定语义定义并有严格语法的语言表达的规范风格。

半形式化（*semiformal*）：采用具有确定语义定义并有严格语法的语言表达的规范风格。

非形式化（*informal*）：采用自然语言表达的规范风格

## 优缺点

用自然语言书写的系统规格说明书，可能存在矛盾、二义性、含糊性、不完整性及抽象层次混乱等问题。形式化语言引入了数学定量描述使得问题描述清晰准确。但是会带来的问题是学习成本高，阅读困难、复杂，不能一目了然，不能快速沟通，除非对方也是形式化语言的精通使用者。这种精确的描述通常会用在学术领域中，理论研究中，在跟生产结合的比较紧密的过程，一般采用较少。

## 有穷状态机

使用更形式化的术语，一个有穷状态机可以表示为一个5元组(J，K，T，S，F)，其中：

-  J是一个有穷的非空状态集；
-  K是一个有穷的非空输入集；
-  T是一个从(J-F)×K到J的转换函数；
-  S∈J，是一个初始状态；
-  F 属于 J，是终态集。

有穷状态机的概念在计算机系统中应用得非常广泛。
例如，每个菜单驱动的用户界面都是一个有穷状态机的实现。一个菜单的显示和一个状态相对应，键盘输入或用鼠标选择一个图标是使系统进入其他状态的一个事件。状态的每个转换都具有下面的形式：

​                                                     **==当前状态〔菜单〕+事件〔所选择的项〕=>下个状态。==**

这个东西对需求的描述可以做到穷尽和准确，但是会出现大量符号语言，对使用环境有较大的要求。

不过，可以使用半形式化语言，加上适量这个形式化描述，那么别人将对你刮目相看，威力巨大。



# 概要设计

总体设计的基本目的就是回答“概括地说，系统应该如何实现”这个问题，因此，总体设计又称为概要设计或初步设计。除了确定的方案，还有就是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。

## 设计过程

![image-20201104224254689](https://tva1.sinaimg.cn/large/0081Kckwgy1gkditpmeo4j30db07at92.jpg)

![image-20201104224340312](https://tva1.sinaimg.cn/large/0081Kckwgy1gkdiug7w1lj30ov07lgng.jpg)



- 设想供选择的方案：需求分析阶段得出的数据流图是总体设计的极好的出发点。
- 选取合理方案：从前一步得到的一系列供选择的方案中选取若干个合理的方案（1个或多个，一般不超过3个）。并对方案做简要分析
- 推荐最佳方案：给出最佳方案，并附带该方案的详细实现计划
- **功能分解和软件结构：首先进行结构设计，然后进行过程设计。再给出软件结构层次图。**
- 数据库设计：设计好数据存储

其他的流程可要可不要，酌情对待，不一定按部就班，灵活变通。

## 设计原理

### 模块化

模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。

下面论证一下为啥要模块化？

设函数C(x)定义问题x的复杂程度，函数E(x)确定解决问题x需要的工作量(时间)。对于两个问题P1和P2，如果C(P1)>C(P2) ，显然  E(P1)>E(P2) ，根据人类解决一般问题的经验，另一个有趣的规律是

C(P1+P2)>C(P1)+C(P2)

也就是说，如果一个问题由P1和P2两个问题组合而成，那么它的复杂程度大于分别考虑每个问题时的复杂程度之和。
综上所述，得到下面的不等式
E(P1+P2)>E(P1)+E(P2)
这个不等式导致“各个击破”的结论——把复杂的问题分解成许多容易解决的小问题，原来的问题也就容易解决了。这就是模块化的根据。

当模块数目增加时每个模块的规模将减小，开发单个模块需要的成本(工作量)确实减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。根据这两个因素，得出了图中的总成本曲线。每个程序都 相应地有一个最适当的模块数目M，使得系统的开发成本最小。

![image-20201105180251133](https://tva1.sinaimg.cn/large/0081Kckwgy1gkegcmyxioj30cy08xwf2.jpg)

### 模块规模适中

### 模块深度、宽度、扇出、扇入适当

深度：软件结构中控制的层数
宽度：软件结构内同一个层次上的模块总数的最大值
扇出：一个模块直接控制(调用)的模块数目 （一般3—4之间，上限是5- 9）
扇入：一个模块被多少个上级模块直接调用的数目



# 详细设计

根本目标：确定应该怎样具体地实现所要求的系统。详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。
详细设计的结果基本上决定了最终的程序代码的质量。

## 程序流程图

程序流程图又称为程序框图，它是使用最广泛的描述过程设计的方法。程序流程图中使用的符号(a) 选择(分支)； (b) 注释； (c) 预先定义的处理； (d) 多分支； (e) 开始或停止； (f) 准备； (g) 循环上界限； (h) 循环下界限； (i) 虚线； (j) 省略符； (k) 并行方式； (l) 处理； (m) 输入输出；  (n) 连接； (o) 换页连接； (p) 控制流

![image-20201105190844878](https://tva1.sinaimg.cn/large/0081Kckwgy1gkei94yfz6j30no09w0sx.jpg)



一般而言，详细设计的阶段学术定义和产品原型图、交互图传达的意思一致，这里，作为程序开发，不必过分关注这些。了解就好了。

# 实现

把编码和测试统称为实现。

编码就是把软件设计结果翻译成用某种程序设计语言书写的程序，是对设计的进一步具体化。

程序的质量主要取决于软件设计的质量。软件测试是保证软件质量的关键步骤，是对软件规格说明、设计和编码的最后复审。

## 编码

主要分为选择编程语言，编程语言有汇编、高级语言。在追求效率时，可以选择汇编，其他时候尽可能的选择高级语言，因为高级语言面向对象、语法丰富、容易阅读、编写更加适合人类，汇编适合机器。

同时，准守一些常见的规则，这些规则可以自己总结或内部团队达成一致，或者借鉴大厂的现有规范，或者行业规则。

## 测试

测试的正确定义是“为了发现程序中的错误而执行程序的过程”。应该认识到测试决不能证明程序是正确的。即使经过了最严格的测试之后，仍然可能还有没被发现的错误潜藏在程序中。

### 测试准则

- 所有测试都应该能追溯到用户需求；
- 应该远在测试开始之前就制定出测试计划；一般在需求确定之后即可开始进行用例编写。
- 测试发现的问题 80%是由20%模块产生的，符合二八定律；同样，可能百分八十的问题是百分之二十的产生的。
- 应该从“小规模”测试开始，并逐步进行“大规模”测试；
- 穷举测试是不可能的；
- 为了达到最佳的测试效果，应该由独立的第三方从事测试工作。  

### 测试方法

 **黑盒测试（功能测试）**

把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。只检查程序功能是否能按照规格说明书的规定正常使用。

**白盒测试（结构测试）**

把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。即测试人员知道代码逻辑，然后设计用例。

### 测试步骤

大型软件系统通常由若干个子系统组成，每个子系统又由许多模块组成，因此，大型软件系统的测试过程基本上由模块测试、子系统测试、系统测试、验收测试和平行运行（预生产环境预发布）等五个步骤组成。

#### 模块测试（单元测试）

模块测试的目的是保证每个模块作为一个单元能正确运行，所以模块测试通常又称为单元测试。模块是完一个清晰定义的子功能，而且这个子功能和同级其他模块的功能之间没有相互依赖关系。因此，有可能把每个模块作为一个单独的实体来测试。

这个可以让开发去实现单元测试。这也是开发要测试的原因，保证每个模块可用，提高自身的代码质量。

#### **（子）系统测试**（集成测试）

（子）系统测试是把经过测试的模块或子系统装配成一个完整的系统来测试。在这个过程中不仅应该发现设计和编码的错误，还应该验证系统确实能提供需求说明书中指定的功能，而且系统的动态特性也符合预定要求。在这个测试步骤中发现的往往是软件设计中的错误，也可能发现需求说明中的错误。

#### 验收测试

验收测试把软件系统作为单一的实体进行测试，测试内容与系统测试基本类似，但是它是在用户积极参与下进行的，而且可能主要使用实际数据(系统将来要处理的信息)进行测试。这个过程在实际生产中，由产品方去验收；

#### 平行运行

所谓平行运行就是同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。或者有的做法是预发布，在预发布环境中，灰度上线等措施，本质和平行运行是一样的。

## 单元测试

单元测试集中检测软件设计的最小单元——模块。单元测试和编码属于软件过程的同一个阶段。

> 实际生产中，研发的自测就是单元测试。

重点关注以下方面：

- 重要的执行通路：程序运行的关键路径
- 错误处理
- 边界条件

## 集成测试

集成测试是测试和组装软件的系统化技术。

由模块组装成程序时有两种方法。一种方法是先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，这种方法称为非渐增式测试方法；另一种方法是把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试，这种方法实际上同时完成单元测试和集成测试。

### 自顶向下集成

自顶向下集成方法是从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。在把附属于（及最终附属于）主控制模块的那些模块组装到程序结构中去时，或者使用深度优先的策略，或者使用宽度优先的策略。

### 自底向上集成

从“原子”模块(即在软件结构最低层的模块)开始组装和测试。因为是从底部向上结合模块，总能得到所需的下层模块处理功能，所以不需要存根程序。

- ==自顶向下测试方法的主要优点是不需要测试驱动程序，能够在测试阶段的早期实现并验证系统的主要功能，而且能在早期发现上层模块的接口错误。==
- ==自顶向下测试方法的主要缺点是需要存根程序，可能遇到与此相联系的测试困难，低层关键模块中的错误发现较晚，而且用这种方法在早期不能充分展开人力。==
- ==自底向上测试方法的优缺点与上述自顶向下测试方法的优缺点刚好相反。==



## 回归测试

在集成测试的范畴中，回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。

> 实际生产中，回归测试指开发人员在修复bug后，重新提交代码，然后进行测试。也是一种全面的测试，通过之后，意味着就要上线。

回归测试集（已执行过的测试用例的子集）包括下述3类不同的测试用例。   

 (1) 检测软件全部功能的代表性测试用例。
 (2) 专门针对可能受修改影响的软件功能的附加测试。
 (3) 针对被修改过的软件成分的测试。

可以针对不同的点进行回归。



## 确认测试

确认测试也称为验收测试，它的目标是验证软件的有效性。通常，验证指的是保证软件正确地实现了某个特定要求的一系列活动；确认指的是为了保证软件确实满足了用户需求而进行的一系列活动。

确认测试必须有用户积极参与，或以用户为主进行。用户应该参与设计测试方案，使用用户界面输入测试数据并且分析评价测试的输出结果。通常以黑盒功能性验收为准。

### Alpha和Beta测试

**Alpha**

Alpha测试由用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题。

**Beta**

由软件的最终用户们在一个或多个客户场所进行。与Alpha测试不同，开发者通常不在Beta测试的现场



**Alpha测试**在受控的环境中进行的。**Beta测试**是软件在开发者不能控制的环境中的“真实”应用



## 白盒测试

通常把测试数据和预期的输出结果称为**测试用例**。

不同的测试数据发现程序错误的能力差别很大，为了提高测试效率降低测试成本，应该选用高效的测试数据。因为不可能进行穷尽的测试，所以选用少量“最有效的”测试数据，做到尽可能完备的测试就更重要了。

测试数据要 做到逻辑覆盖、路径覆盖

## 黑盒测试

黑盒测试并不能取代白盒测试，它是与白盒测试互补的测试方法，它很可能发现白盒测试不易发现的其他类型的错误。

(1) 功能不正确或遗漏了功能；
(2) 界面错误；
(3) 数据结构错误或外部数据库访问错误；
(4) 性能错误；
(5) 初始化和终止错误。



## 调试



## 软件可靠性

软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。软件可靠性随着给定的时间间隔的加大而减少。 一般说来，对于任何其故障是可以修复的系统，都应该同时使用可靠性和可用性衡量它的优劣程度。

软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。

一般而言，如果要定量的分析这个可靠性，是一个专业的事情，也是比较复杂的。一般是事后统计，在测试阶段发现问题量来进行比对。或者设计制度驱动开发、测试减少线上问题。



# 软件维护

这个阶段是软件生命周期的最后一个阶段，其基本任务是保证软件在一个相当长的时期能够正常运行。软件维护需要的工作量很大，平均说来，大型软件的维护成本高达开发成本的4倍左右。软件工程的主要目的就是要提高软件的可维护性，减少软件维护所需要的工作量，降低软件系统的总成本。

软件一般都会迭代循环的，实际开发中，都是重复前面的步骤。没有刻意说是软件维护，更倾向于迭代，所以，这里我们只需掌握理论知识哈。

## 软件维护定义

定义：在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程

常见的维护活动有下面几项：

1. 改正性维护：在任何大型程序的使用期间，用户必然会发现程序错误，并且把他们遇到的问题报告给维护人员。把诊断和改正错误的过程称为改正性维护。
2. 完善性维护：在使用软件的过程中用户往往提出增加新功能或修改已有功能的建议，还可能提出一般性的改进意见。为了满足这类要求，需要进行完善性维护。这项维护活动通常占软件维护工作的大部分。
3. 适应性维护：为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动。
4. 预防性维护：当为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件时，而进行的维护称为预防性维护，目前这项维护活动相对比较少。

上述维护，完善性维护占比最多，其实就是需求的不断迭代，当然其占比最大。需求的新增也是软件更新发展的主要驱动力。

## 维护特点

**非结构化维护**

如果软件配置的唯一成分是程序代码，那么维护活动需要付出很大代价。因为没有其他参考物去快速准确的了解软件功能、特性等事项。

**结构化维护**

如果有一个完整的软件配置存在，那么维护工作从评价设计文档开始，确定软件重要的结构、性能以及接口等特点；估量要求的改动将带来的影响，并且计划实施途径

**维护过程中问题**

（1）理解别人写的程序通常非常困难，而且困难程度随着软件配置成分的减少而迅速增加。如果仅有程序代码没有说明文档，则会出现严重的问题。
（2） 需要维护的软件往往没有合格的文档，或者文档资料显著不足。认识到软件必须有文档仅仅是第一步，容易理解的并且和程序代码完全一致的文档才真正有价值。

  (3） 当要求对软件进行维护时，不能指望由开发人员给人们仔细说明软件。由于维护阶段持续的时间很长，因此，当需要解释软件时，往往原来写程序的人已经不在附近了。
（4） 绝大多数软件在设计时没有考虑将来的修改。除非使用强调模块独立原理的设计方法学，否则修改软件既困难又容易发生差错。
（5）  软件维护不是一项吸引人的工作。形成这种观念很大程度上是因为维护工作经常遭受挫折

## 维护过程

如果把一次的大维护工作当作是迭代，那就采取和之前的研发流程。如果是一些临时性的，短时间的，可以准守一些规则：

- 首先必须建立一个维护组织
- 随后必须确定报告和评价的过程
- 必须为每个维护要求规定一个标准化的事件序列，此外，还应该建立一个适用于维护活动的记录保管过程，并且规定复审标准。
- 维护表：记录整个过程人、事、物等因素。

## 软件的可维护性

维护就是在软件交付使用后进行的修改，修改之前必须理解待修改的对象，修改之后应该进行必要的测试，以保证所做的修改是正确的。如果是改正性维护，还必须预先进行调试以确定错误的具体位置。因此，决定软件可维护性的因素主要有下述5个。
可理解性：软件结构、相关文档
可测试性：测试相关文档
可修改性：软件设计思路、结构
可移植性
可重用性

就不一一展开了。其中文档是整个文化的决定因素，文档（指正确的文档，不完整或者错误的文档大打折扣）比代码重要。

### 文档

文档可以分为用户文档和系统文档两类。
**用户文档**
用户文档是用户了解系统的第一步，它应该能使用户获得对系统的准确的初步印象。
 (1)功能描述
 (2) 安装文档
 (3) 使用手册
 (4) 参考手册（要完整）
 (5) 操作员指南(如果需要有系统操作员的话)

**系统文档**

所谓系统文档指从问题定义、需求说明到验收测试计划这样一系列和系统实现有关的文档。描述系统设计、实现和测试的文档对于理解程序和维护程序来说是极端重要的。
和用户文档类似，系统文档的结构也应该能把读者从对系统概貌的了解，引导到对系统每个方面每个特点的更形式化更具体的认识。

## 软件再工程

![image-20201106180056404](https://tva1.sinaimg.cn/large/0081Kckwgy1gkflwy9mytj30dh0a0dnb.jpg)



软件再工程过程模型如上图。在某些情况下这些活动以线性顺序发生，但也并非总是这样。下面解释其含义：

### 库存目录分析

每个软件组织都应该保存其拥有的所有应用系统的库存目录。该目录包含关于每个应用系统的基本信息。

> 应用系统的名字，最初构建它的日期，已做过的实质性修改次数，过去18个月报告的错误，用户数量，安装它的机器数量，它的复杂程度，文档质量，整体可维护性等级，预期寿命，在未来36个月内的预期修改次数，业务重要程度等

### 文档重构

老程序固有的特点是缺乏文档。具体情况不同，处理这个问题的方法也不同。

(1) 建立文档非常耗费时间，不可能为数百个程序都重新建立文档。如果一个程序是相对稳定的，正在走向其有用生命的终点，而且可能不会再经历什么变化，那么，让它保持现状是一个明智的选择。
(2) 为了便于今后的维护，必须更新文档，但是由于资源有限，应采用“使用时建文档”的方法。
(3) 如果某应用系统是完成业务工作的关键，而且必须重构全部文档，则仍然应该设法把文档工作减少到必需的最小量。

### 逆向工程

软件的逆向工程是分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程，也就是说，逆向工程是一个恢复设计结果的过程，逆向工程工具从现存的程序代码中抽取有关数据、体系结构和处理过程的设计信息。

### 代码重构

代码重构是最常见的再工程活动。某些老程序具有比较完整、合理的体系结构，但是，个体模块的编码方式却是难于理解、测试和维护的。在这种情况下，可以重构可疑模块的代码。

- 首先，用重构工具分析源代码，标注出和结构化程序设计概念相违背的部分
- 然后，重构有问题的代码（此项工作可自动进行）
- 最后，复审和测试生成的重构代码（以保证没有引入异常）并更新代码文档。

### 数据重构

与代码重构不同，数据重构发生在相当低的抽象层次上，它是一种全范围的再工程活动——对数据的修改必然会导致体系结构或代码层的改变。在大多数情况下，数据重构始于逆向工程活动，分解当前使用的数据体系结构，必要时定义数据模型，标识数据对象和属性，并从软件质量的角度复审现存的数据结构。

### 正向工程

正向工程也称为革新或改造，这项活动不仅从现有程序中恢复设计信息，而且使用该信息去改变或重构现有系统，以提高其整体质量。

## 小结

1. 维护是软件生命周期的最后一个阶段，也是持续时间最长、代价最大的一个阶段。软件工程学的主要目的就是提高软件的可维护性，降低维护的代价。
2. 软件维护通常包括4类活动：改正性维护、适应性维护、完善性维护、预防性维护。
   软件的可理解性、可测试性、可修改性、可移植性和可重用性，是决定软件可维护性的基本因素。
3. 在软件生命周期的每个阶段都必须充分考虑维护问题，并且为软件维护预做准备。
4. 文档是影响软件可维护性的决定因素。（前提是正确的文档）
5. 在条件具备时应该主动地进行预防性维护。
6. 预防性维护实质上是软件再工程。
7. 典型的软件再工程过程模型定义了库存目录分析、文档重构、逆向工程、代码重构、数据重构和正向工程6类活动。



# 软件项目管理

所谓管理就是通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命周期之中。

## 软件规模估算

### 代码行技术

用代码行技术估算软件规模时，当程序较小时常用的单位是代码行数（LOC），当程序较大时常用的单位是千行代码数（KLOC）。该方法通用性比较好，因为所有的软件产品都用的代码实现的。其缺点：

- 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模似乎不太合理；
- 用不同语言实现同一个软件所需要的代码行数并不相同；

这里只是简单介绍，具体做法可看本书籍或其他专业介绍。

### 功能点技术

依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。这种方法用功能点（FP）为单位度量软件规模。可以大致的估算出软件规模。

## 工作量估算

像这些东西，都有专门的计算方法，而现实生产中，大都凭借经验来估算工作量。所以按理论参考实际意义不大，也不太会执行。知道有这个理论就行了。

## 进度计划

一个软件过程应该定义一个适用于当前项目的任务集合。一个任务集合包括软件工程工作任务、里程碑和可交付的产品。为一个项目定义的任务集合必须包含所有子任务，但又不能包含一些不必要的工作。

项目管理者要定义全部任务，识别关键任务，并跟踪任务。指定进度计划表。

### 估算开发时间

估算时间也有理论公式，但实际中不常用。但是要注意人员规模和生产率的协调，不能无限增加人员缩减总工期，因为随着人员增加个人的生产率会下降，主要是沟通协调的时间随着人员规模增加而递增，导致其实际生产效率下降。

相应的软件工具是windows project 或 omin plan 

## 人员组织

软件项目成功的关键是有高素质的软件开发人员。就是开发人员的组织架构，是否有一个人作为领导带领其他人员进行开发；还可以采取扁平化组织架构，每个开发人员都是平级的，大家能尽情发挥和无压力沟通。

### 扁平化架构

项目小组成员之间是扁平化的，每个人都是完全平等，没有上下级关系。这种使用于小组成员能力相当，经验丰富的；这种架构可以最大程度上发挥个人能力，激发成员活力；

### 现代程序组

选择一个技术组长，来带领其他小组成员；技术组长负责技术调研、技术攻关。同时配备一个项目管理人员，负责项目事情及行政事务。这种方式有利于对接和任务的快速传达。

## 质量保证

软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。

上述定义强调了下述的3个要点。 
（1）  软件需求是度量软件质量的基础，与需求不一致就是质量不高。
（2） 指定的开发标准定义了一组指导软件开发的准则，如果没有遵守这些准则，肯定会导致软件质量不高。
（3） 通常，有一组没有显式描述的隐含需求（例如，软件应该是容易维护的）。

从管理角度对软件质量的度量。可以把这些质量因素分成3组： 产品运行、产品修改和产品转移

![image-20201109145444165](https://tva1.sinaimg.cn/large/0081Kckwgy1gkixe2tx91j30kn0asjvq.jpg)

![image-20201109145500365](https://tva1.sinaimg.cn/large/0081Kckwgy1gkixed7gegj30os0jc143.jpg)

### 软件质量保证

软件质量保证（software quality assurance, SQA）的措施主要有：基于非执行的测试（也称为复审或评审），基于执行的测试（即以前讲过的软件测试）和程序正确性证明。

还有软件质量控制 software quality control SQC ：主要是发现软件中问题，缺陷确保质量；注意是测试人员对软件的bug发现，开发修复过程保证质量。

关于QA、QC 可以看文章：https://wenku.baidu.com/view/c4511922482fb4daa58d4b09.html

#### 技术复审

正式技术复审的显著优点是，能够较早发现软件错误，从而可防止错误被传播到软件过程的后续阶段。

#### 走查和审查

走查组组长引导该组成员走查文档，力求发现尽可能多的错误。走查组的任务仅仅是标记出错误而不是改正错误，改正错误的工作应该由该文档的编写组完成。走查的时间最长不要超过2小时，这段时间应该用来发现和标记错误，而不是改正错误。

可以组织参与者讲解或者讲解之前的文档设计等形式。

## 软件配置管理

软件配置管理是在软件的整个生命期内管理变化的一组活动。

具体地说，这组活动用来：  
（1） 标识变化。
（2） 控制变化。
（3） 确保适当地实现了变化。
（4） 向需要知道这类信息的人报告变化。

软件配置管理不同于软件维护。维护是在软件交付给用户使用后才发生的，而配置管理是在软件项目启动时就开始，并且一直持续到软件退役后才终止的一组跟踪和控制活动

**软件配置管理的目标是，使变化更正确且更容易被适应，在必须变化时减少所需花费的工作量。**

### 软件配置

#### 软件配置

软件配置项指的软件过程中有哪些可以配置的项目，比如程序、文档、数据这几大类，还可以随项目变化而变化，比如说环境也可以作为配置项。随着软件开发过程的进展，软件配置项的数量迅速增加。

#### 基线

已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它。生产中某个版本发布后版本可以称为基线，为下一次版本开发作为基础。

## 能力成熟度模型

能力成熟度模型的基本思想是，由于问题是由人们管理软件过程的方法不当引起的，所以新软件技术的运用并不会自动提高软件的生产率和质量

软件过程包括各种活动、技术和工具，因此，它实际上既包括了软件开发的技术方面又包括了管理方面。CMM的策略是，力图改进对软件过程的管理，而在技术方面的改进是其必然的结果。CMM把软件过程从无序到有序的进化过程分成5个阶段，并把这些阶段排序，形成5个逐层提高的等级。CMM对5个成熟度级别特性的描述，说明了不同级别之间软件过程的主要变化。从“1级”到“5级”，反映出一个软件机构为了达到从一个无序的、混乱的软件过程进化到一种有序的、有纪律的且成熟的软件过程的目的，必须经历的过程改进活动的途径。

### 初始级

软件过程的特征是无序的，有时甚至是混乱的。几乎没有什么过程是经过定义的（即没有一个定型的过程模型），项目能否成功完全取决于开发人员的个人能力。
处于这个最低成熟度等级的软件机构，基本上没有健全的软件工程管理制度，其软件过程完全取决于项目组的人员配备，所以具有不可预测性，人员变了过程也随之改变。如果一个项目碰巧由一个杰出的管理者和一支有经验、有能力的开发队伍承担，则这个项目可能是成功的。但是，更常见的情况是，由于缺乏健全的管理和周密的计划，延期交付和费用超支的情况经常发生，结果，大多数行动只是应付危机，而不是完成事先计划好的任务。

总之，处于1级成熟度的软件机构，其过程能力是不可预测的，其软件过程是不稳定的，产品质量只能根据相关人员的个人工作能力而不是软件机构的过程能力来预测

### 可重复级

软件机构建立了基本的项目管理过程(过程模型),可跟踪成本、进度、功能和质量。已经建立起必要的过程规范，对新项目的策划和管理过程是基于以前类似项目的实践经验，使得有类似应用经验的软件项目能够再次取得成功。达到2级的一个目标是使项目管理过程稳定，从而使得软件机构能重复以前在成功项目中所进行过的软件项目工程实践。
         处于2级成熟度的软件机构，针对所承担的软件项目已建立了基本的软件管理控制制度。通过对以前项目的观察和分析，可以提出针对现行项目的约束条件。

>  处于2级成熟度的软件机构的过程能力可以概括为，软件项目的策划和跟踪是稳定的，已经为一个有纪律的管理过程提供了可重复以前成功实践的项目环境。软件项目工程活动处于项目管理体系的有效控制之下，执行着基于以前项目的准则且合乎现实的计划。

### 已定义级

软件机构已经定义了完整的软件过程（过程模型），软件过程已经文档化和标准化。所有项目组都使用文档化的、经过批准的过程来开发和维护软件。这一级包含了第2级的全部特征。

在第3级成熟度的软件机构中，有一个固定的过程小组从事软件过程工程活动。当需要时，过程小组可以利用过程模型进行过程例化活动，从而获得一个针对某个特定的软件项目的过程实例，并投入过程运作而开展有效的软件项目工程实践。同时，过程小组还可以推进软件机构的过程改进活动。在该软件机构内实施了培训计划，能够保证全体项目负责人和项目开发人员具有完成承担的任务所要求的知识和技能。

> 处于3级成熟度的软件机构的过程能力可以概括为，无论是管理活动还是工程活动都是稳定的。软件开发的成本和进度以及产品的功能和质量都受到控制，而且软件产品的质量具有可追溯性。这种能力是基于在软件机构中对已定义的过程模型的活动、人员和职责都有共同的理解。

### 已管理级

软件机构对软件过程（过程模型和过程实例）和软件产品都建立了定量的质量目标，所有项目的重要的过程活动都是可度量的。该软件机构收集了过程度量和产品度量的方法并加以运用，可以定量地了解和控制软件过程和软件产品，并为评定项目的过程质量和产品质量奠定了基础。这一级包含了第3级的全部特征。

> 处于4级成熟度的软件机构的过程能力可以概括为，软件过程是可度量的，软件过程在可度量的范围内运行。这一级的过程能力允许软件机构在定量的范围内预测过程和产品质量趋势，在发生偏离时可以及时采取措施予以纠正，并且可以预期软件产品是高质量的。

### 优化级

软件机构集中精力持续不断地改进软件过程。这一级的软件机构是一个以防止出现缺陷为目标的机构，它有能力识别软件过程要素的薄弱环节，并有足够的手段改进它们。在这样的机构中，可以获得关于软件过程有效性的统计数据，利用这些数据可以对新技术进行成本/效益分析，并可以优化出在软件工程实践中能够采用的最佳新技术。这一级包含了第4级的全部特征。

>  处于5级成熟度的软件机构的过程能力可以概括为，软件过程是可优化的。这一级的软件机构能够持续不断地改进其过程能力，既对现行的过程实例不断地改进和优化，又借助于所采用的新技术和新方法来实现未来的过程改进。

总结：

一些统计数字表明，提高一个完整的成熟度等级大约需要花18个月到3年的时间，但是从第1级上升到第2级有时要花3年甚至5年时间。这说明要向一个迄今仍处于混乱的和被动的行动方式的软件机构灌输系统化的方式，将是多么困难。



# 通用模版

这里的模版指的是我们在实际开发过程中，如果遇到软件过程中的某个环节，需要研发去出文档，该如何写这些文档，如何谋篇布局。这里讲一下 对于某个技术设计（包含概要设计、详细设计）

比如说 《认证流程动态化方案》这个问题出一个技术方案。则技术方案的整体布局可有如下几部分：

**前言**

说明该文档的作用。同时指出该文档对应的软件版本（相当于版本管理），可用下面表格标注出来。

| 文档版本 | 软件版本 | 内容                       | 作者 | 时间      |
| -------- | -------- | -------------------------- | ---- | --------- |
| 1.0      | V3.0     | 《认证流程动态化》设计方案 | sjh  | 2020.1.10 |
| 2.0      | V3.5     | 修改 “页面组装实现方式”    | 小王 | 2020.5.10 |

**需求概述**

引用 “需求分析说明书” 的内容，进行文档设计背后的需求简要概述。

**[方案提供]**

如果有超过1个方案的时候，需要分别叙述方案，并进行对比，并选择出最佳方案。

**概要说明**

一般的，若只有一个方案就省略上一步的方案提供，直接叙述，说出整体思路（文字描述），并配有系统流程图/层次图（可以整体的表面软件架构的图例） 进行说明。

**详细设计**

​      **结构设计**

​      结构设计确定程序有哪些模块组成，以及模块之间的关系；并配图说明（软件层次图）。

​      **过程设计**       

​      确定每个模块的处理过程，并配程序流程图；面向对象的类图、时序图、状态图。

如果概要设计和结构设计重合了，可以只要一个，或者说一个比较小的功能点，可以省略结构设计、直接过程设计即可。这些只是通用框架。

**数据库设计**

数据库方面就看情况而定

**补充说明**

对方案的补充说明，或者对测试的建议等。