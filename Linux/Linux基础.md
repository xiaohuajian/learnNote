# 文件权限与目录

## 用户与用户组

Linux非常最要的一点就是多人多任务，这个特点使的我们需要对一个文件进行权限管理，所以，文件的权限管理也是非常重要的一点。**linux将文件的身份分为三个类别，拥有者owner、所属群组　group 、其他人other ，他们对文件具有不同的读、写、执行权限**。下面举一例子，可以类比我们用ｓｖｎ、ｇｉｔ这种版本管理工具进行文件管理时对不同人具有不同的权限一样。比如说：在开发一个新功能，项目组长Ａ创建了一个工程，并把这个工程代码文件相应的权限给了同组人，同时组Ｂ成员则无法访问刚才的工程；以上场景进行映射就是　项目组长是ｏｗｎｅｒ，该组的人是同属一个群组ｇｒｏｕｐ；其他组的人就是ｏｔｈｅｒ；组长可以对组内的人授予读写权限，可以对其他人设置只读权限、或者完全不可见。有一位系统管理员可以看到所有组创建的工程和代码，那就是超级管理员root；

> 在我们Linux系统当中，默认的情况下，所有的系统上的账号与一般身份使用者，还有那个root的相关信息， 都是记录在/etc/passwd这个文件内的。至于个人的密码则是记录在/etc/shadow这个文件下。 此外，Linux所有的组名都纪录在/etc/group内

## 权限概念

打开终端命令行，输入　`ls -al`，会显示下面信息：

```
[root@www ~]# ls -al
total 156
drwxr-x---   4    root   root     4096   Sep  8 14:06 .
drwxr-xr-x  23    root   root     4096   Sep  8 14:21 ..
-rw-------   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg
-rw-------   1    root   root      199   Sep  8 17:14 .bash_history
-rw-r--r--   1    root   root       24   Jan  6  2007 .bash_logout
-rw-r--r--   1    root   root      191   Jan  6  2007 .bash_profile
-rw-r--r--   1    root   root      176   Jan  6  2007 .bashrc
-rw-r--r--   1    root   root      100   Jan  6  2007 .cshrc
drwx------   3    root   root     4096   Sep  5 10:37 .gconf      <=范例说明处
drwx------   2    root   root     4096   Sep  5 14:09 .gconfd
-rw-r--r--   1    root   root    42304   Sep  4 18:26 install.log <=范例说明处
-rw-r--r--   1    root   root     5661   Sep  4 18:25 install.log.syslog
[    1   ][  2 ][   3  ][  4 ][    5   ][     6     ][       7          ]
[  权限  ][连结][拥有者][群组][文件容量][  修改日期 ][      檔名        ]
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://img-blog.csdnimg.cn/20191208231329374.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

第一栏代表这个文件的类型与权限(permission)：

这个地方最需要注意了！仔细看的话，你应该可以发现这一栏其实共有十个字符。

![img](https://img-blog.csdnimg.cn/20191208231435423.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

- 第一个字符代表这个文件是『目录、文件或链接文件等等』：

  - 当为[ d ]则是目录，例如[上表](http://cn.linux.vbird.org/linux_basic/0210filepermission_2.php#table2.1.1)文件名为『.gconf』的那一行；
  - 当为[ - ]则是文件，例如[上表](http://cn.linux.vbird.org/linux_basic/0210filepermission_2.php#table2.1.1)文件名为『install.log』那一行；
  - 若是[ l ]则表示为连结档(link file)；
  - 若是[ b ]则表示为设备文件里面的可供储存的接口设备(可随机存取设备)；
  - 若是[ c ]则表示为设备文件里面的串行端口设备，例如键盘、鼠标(一次性读取设备)。

- 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。

  - 第一组为『文件拥有者的权限』，以『install.log』那个文件为例， 该文件的拥有者可以读写，但不可执行；
  - 第二组为『同群组的权限』；
  - 第三组为『其他非本群组的权限』

  |             | 内容         | 叠代物件   | r            | w            | x                     |
  | ----------- | ------------ | ---------- | ------------ | ------------ | --------------------- |
  | 文件        | 详细资料data | 文件资料夹 | 读到文件内容 | 修改文件内容 | 执行文件内容          |
  | 目录/文件夹 | 文件名       | 可分类抽屉 | 读到文件名   | 修改文件名   | 进入该目录的权限(key) |

- 第二栏表示有多少文件名连结到此节点(i-node)

- 第三栏表示这个文件(或目录)的『拥有者账号』

- 第四栏表示这个文件的所属群组

- 在Linux系统下，你的账号会附属于一个或多个的群组中。举刚刚我们提到的例子，class1, class2, class3均属于projecta这个群组，假设某个文件所属的群组为projecta，且该文件的权限如图2.1.2所示(-rwxrwx---)， 则class1, class2, class3三人对于该文件都具有可读、可写、可执行的权限(看群组权限)。 但如果是不属于projecta的其他账号，对于此文件就不具有任何权限了。

- 第五栏为这个文件的容量大小，默认单位为bytes；

- 第六栏为这个文件的建档日期或者是最近的修改日期：

  - 这一栏的内容分别为日期(月/日)及时间。如果这个文件被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。 如下所示：

    `[root@www ~]# ls -l /etc/termcap /root/install.log-rw-r--r-- 1 root root 807103 Jan  7  2007 /etc/termcap-rw-r--r-- 1 root root  42304 Sep  4 18:26 /root/install.log# 如上所示，/etc/termcap 为 2007 年所修改过的文件，离现在太远之故；# 至于 install.log 是今年 (2009) 所建立的，所以就显示完整的时间了。`

    如果想要显示完整的时间格式，可以利用ls的选项，亦即：『ls -l --full-time』就能够显示出完整的时间格式了！包括年、月、日、时间喔。 另外，如果你当初是以繁体中文安装你的Linux系统，那么日期字段将会以中文来显示。 可惜的是，中文并没有办法在纯文本的终端机模式中正确的显示，所以此栏会变成乱码。 那你就得要使用『LANG=en_US』来修改语系喔！

- 第七栏为这个文件名字

### Linux文件权限的重要性：

与Windows系统不一样的是，在Linux系统当中，每一个文件都多加了很多的属性进来，尤其是群组的概念，这样有什么用途呢？ 其实，最大的用途是在『数据安全性』上面的。

- **系统保护的功能：**
  举个简单的例子，在你的系统中，关于系统服务的文件通常只有root才能读写或者是执行，例如/etc/shadow这一个账号管理的文件，由于该文件记录了你系统中所有账号的数据， 因此是很重要的一个配置文件，当然不能让任何人读取(否则密码会被窃取啊)，只有root才能够来读取啰！所以该文件的权限就会成为[ -rw------- ]啰！

  

- **团队开发软件或数据共享的功能：**
  此外，如果你有一个软件开发团队，在你的团队中，你希望每个人都可以使用某一些目录下的文件， 而非你的团队的其他人则不予以开放呢？以上面的例子来说，testgroup的团队共有三个人，分别是test1, test2, test3，那么我就可以将团队所需的文件权限订为[ -rwxrwx--- ]来提供给testgroup的工作团队使用啰！

  

- **未将权限设定妥当的危害：**
  例如本来只有root才能做的开关机、ADSL的拨接程序、新增或删除用户等等的指令，若被你改成任何人都可以执行的话， 那么如果使用者不小心给你重新启动啦！重新拨接啦！等等的！那么你的系统不就会常常莫名其妙的挂掉啰！ 而且万一你的用户的密码被其他不明人士取得的话，只要他登入你的系统就可以轻而易举的执行一些root的工作！

###  修改文件权限

- chgrp（change group ） ：改变文件所属群组 
- chown （change owner）：改变文件拥有者
- chmod （change modify）：改变文件的权限

**chmod**

**1 数字类型改变文件权限**

Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限；然后

r:4
w:2
x:1

```
[root@study ~]# chmod [-R] xyz文件或目录 eg：chmod -R 777 fileName 
选项与参数：
xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。
-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有文件都会变更
```

2 **符号类型改变文件权限**

九个权限分别是(1)user (2)group (3)others三种身份啦！那么我们就可以藉由**u, g, o**来代表三种身份的权限！此外，**a**则代表all亦即全部的身份:

| chmod | u <br />g<br />o<br />a | +(加入)<br /> -(除去) <br />=(设定) | r<br />w <br />x | 文件或目录 |
| ----- | ----------------------- | ----------------------------------- | ---------------- | ---------- |
|       |                         |                                     |                  |            |

```

[root@study ~]# chmod u=rwx,go=rx .bashrc 
#注意喔！那个u=rwx,go=rx是连在一起的，中间并没有任何空白字符！
chmod a+w .bashrc 

```

### 常见文件扩展名

- *.sh ： 脚本或批次档(scripts)，因为批次档为使用shell写成的，所以副文件名就编成.sh 啰；
- *Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩档。这是因为压缩软体分别为gunzip, tar 等等的，由于不同的压缩软体，而取其相关的扩展名啰！

### 常见命令

|      | /etc/passwd	        保存用户信息                          |
| ---- | ------------------------------------------------------------ |
|      | /etc/shadow	        保存用户密码                          |
|      | /etc/group	        保存用户组                             |
|      | ------------------------------------------------------------------ |
|      | ls -al		        列出所有的档案详细权限与属性 (包含隐藏文件) |
|      | cp		        拷贝档案                                   |
|      | cd		        变更目录                                   |
|      | mkdir		        建立目录                                |
|      | touch		        建立空档案                              |
|      | su		        切换用户(switch user)                      |
|      | rm		        删除目录或档楼(remove)                     |
|      | cat                     读取档案内容                         |
|      | uname                   打印系统信息                         |
|      | lsb_release             显示LSB和特定版本的相关信息          |

## 目录配置FHS

FHS—— Filesystem Hierarchy Standard (FHS) 目录标准。主要为了规范各个目录的作用及含义。说白了，就是让使用者可以了解到已安装软体通常放置于那个目录下。

FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：

|                            | 可分享的(shareable)        | 不可分享的(unshareable) |
| -------------------------- | -------------------------- | ----------------------- |
| 不变的(static)             | /usr (软体放置处)          | /etc (设定档)           |
| /opt (第三方协力软体)      | /boot (开机与核心档)       |                         |
| 可变动的(variable)         | /var/mail (使用者邮件信箱) | /var/run (程序相关)     |
| /var/spool/news (新闻群组) | /var/lock (程序相关)       |                         |

什么是那四个类型？

- 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行档与使用者的邮件等资料，是能够分享给网路上其他主机挂载用的目录；
- 不可分享的：自己机器上面运作的设备文件或者是与程序有关的socket文件等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。
- 不变的：有些资料是不会经常变动的，跟随着distribution而不变动。例如函式库、文件说明档、系统管理员所管理的主机服务设定档等等；
- 可变动的：经常改变的资料，例如登录档、一般用户可自行收受的新闻群组等。

FHS针对目录树架构仅定义出三层目录底下应该放置什么资料而已，分别是底下这三个目录的定义：

- / (root, 根目录)：与开机系统有关；
- /usr (unix software resource)：与软体安装/执行有关；
- /var (variable)：与系统运作过程有关。

### 根目录 /

所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。==因此建议根目录越小越好，这样发生错误的概率就会越小。==

常见目录名称和其作用：

| 目录       | 应放置文件内容                                               |
| ---------- | ------------------------------------------------------------ |
|            | ==第一部份：FHS 要求必须要存在的目录==                       |
| /bin       | ==系统有很多放置执行档的目录，但/bin比较特殊==。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。 |
| /boot      | ==这个目录主要在放置开机会使用到的文件==，包括Linux核心文件以及开机选单与开机所需设定档等等。 Linux kernel常用的文件名为：vmlinuz，如果使用的是grub2这个开机管理程序，则还会存在/boot/grub2/这个目录喔！ |
| /dev       | 在Linux系统上，任何装置与周边设备都是以文件的型态存在于这个目录当中的。你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～比要重要的文件有/dev/null, /dev/zero, /dev/tty , /dev/loop*, / dev/sd*等等 |
| /etc       | ==系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等==。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行档(binary)在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等。另外FHS还规范几个重要的目录最好要存在/etc/目录下喔：<br />/etc/opt(必要)：这个目录在放置第三方协力软体/opt的相关设定档/etc/X11/(建议)：与X Window有关的各种设定档都在这里，尤其是xorg.conf这个X Server的设定档。/etc/sgml/(建议)：与SGML格式有关的各项设定档/etc/xml/(建议)：与XML格式有关的各项设定档 |
| /lib       | 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。另外FHS还要求底下的目录必须要存在：<br />/lib/modules/：这个目录主要放置可抽换式的核心相关模组(驱动程序)喔！ |
| /media     | media是『媒体』的英文，顾名思义，==这个/media底下放置的就是可移除的装置啦==！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。常见的文件名有：/media/floppy, /media/cdrom等等。 |
| /mnt       | 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 |
| /opt       | ==这个是给第三方协力软件放置的目录==。什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ |
| /run       | 早期的FHS 规定系统开机后所产生的各项资讯应该要放置到/var/run 目录下，新版的FHS 则规范到/run 底下。由于/run 可以使用记忆体来模拟，因此效能上会好很多！ |
| /sbin      | Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他使用者最多只能用来『查询』而已。 ==放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令==。 至于某些伺服器软体程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。 |
| /srv       | srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。常见的服务例如WWW, FTP等等。举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。不过，系统的服务资料如果尚未要提供给网际网路任何人浏览的话，预设还是建议放置到/var/lib 底下即可。 |
| /tmp       | 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除唷！ |
| /usr       | 第二层FHS 设定，后续介绍                                     |
| /var       | 第二曾FHS 设定，主要为放置变动性的资料，后续介绍             |
|            | ==**第二部份：FHS 建议可以存在的目录**==                     |
| /home      | 这是系统预设的使用者家目录(home directory)。在你新增一个一般使用者帐号时， 预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号喔：<br />~：代表目前这个使用者的家目录 <br />~ dmtsai：则代表dmtsai的家目录！ |
| /lib<qual> | 用来存放与/lib 不同的格式的二进位函式库，例如支援64 位元的/lib64 函式库等 |
| /root      | 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。 |



### /usr Unix Software Resource

usr 指的是软件资源，而非用户相关，这个目录等价于windows 的 『C:\Windows\ (当中的一部份) + C:\Program files \』这两个目录的综合体，就是安装系统软件和用户自己安装的软件，由于安装了很多软件，所以也会占用大量的硬盘空间。该文件夹下应当有以下目录：

| 目录            | 应放置档案内容                                               |
| --------------- | ------------------------------------------------------------ |
|                 | 第一部份：FHS 要求必须要存在的目录                           |
| /usr/bin/       | 所有一般用户能够使用的指令都放在这里！目前新的CentOS 7 已经将全部的使用者指令放置于此，而使用连结档的方式将/bin 连结至此！也就是说， /usr/bin 与/bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！ |
| /usr/lib/       | 基本上，与/lib 功能相同，所以/lib 就是连结到此目录中的！     |
| /usr/local/     | 系统管理员在本机自行安装自己下载的软体(非distribution预设提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软体较旧，你想安装较新的软体但又不想移除旧版， 此时你可以将新版软体安装于/usr/local/目录下，可与原先的旧版软体有分别啦！你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！ |
| /usr/sbin/      | 非系统正常运作所需要的系统指令。最常见的就是某些网路伺服器软体的服务指令(daemon)啰！不过基本功能与/sbin 也差不多， 因此目前/sbin 就是连结到此目录中的。 |
| /usr/share/     | 主要放置唯读架构的资料档案，当然也包括共享文件。在这个目录下放置的资料几乎是不分硬体架构均可读取的资料， 因为几乎都是文字档案嘛！在此目录下常见的还有这些次目录：/usr/share/man：线上说明文件/usr/share/doc：软体杂项的文件说明/usr/share/zoneinfo：与时区有关的时区档案 |
|                 | 第二部份：FHS 建议可以存在的目录                             |
| /usr/games/     | 与游戏比较相关的资料放置处                                   |
| /usr/include/   | c/c++等程式语言的档头(header)与包含档(include)放置处，当我们以tarball方式(*.tar.gz 的方式安装软体)安装某些资料时，会使用到里头的许多包含档喔！ |
| /usr/libexec/   | 某些不被一般使用者惯用的执行档或脚本(script)等等，都会放置在此目录中。例如大部分的X视窗底下的操作指令，很多都是放在此目录下的。 |
| /usr/lib<qual>/ | 与/lib<qual>/功能相同，因此目前/lib<qual> 就是连结到此目录中 |
| /usr/src/       | 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 |

### /var 

如果/usr是安装时会占用较大硬碟容量的目录，那么/var就是在系统运作后才会渐渐占用硬碟容量的目录。因为/var目录主要针对常态性变动的文件，包括快取(cache)、登录档(log file)以及某些软体运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL资料库的文件等等

| 目录        | 应放置档案内容                                               |
| ----------- | ------------------------------------------------------------ |
|             | 第一部份：FHS 要求必须要存在的目录                           |
| /var/cache/ | 应用程式本身运作过程中会产生的一些暂存档；                   |
| /var/lib/   | 程式本身执行的过程中，需要使用到的资料档案放置的目录。在此目录下各自的软体应该要有各自的目录。举例来说，MySQL的资料库放置到/var/lib/mysql/而rpm的资料库则放到/var/lib/rpm去！ |
| /var/lock/  | 某些装置或者是档案资源一次只能被一个应用程式所使用，如果同时有两个程式使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软体所使用。举例来说，烧录机正在烧录一块光碟，你想一下，会不会有两个人同时在使用一个烧录机烧片？如果两个人同时烧录，那片子写入的是谁的资料？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。目前此目录也已经挪到/run/lock 中！ |
| /var/log/   | 重要到不行！这是登录档放置的目录！里面比较重要的档案如/var/log/messages, /var/log/wtmp(记录登入者的资讯)等。 |
| /var/mail/  | 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！通常这两个目录是互为连结档啦！ |
| /var/run/   | 某些程式或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。与/run 相同，这个目录连结到/run 去了！ |
| /var/spool/ | 这个目录通常放置一些伫列资料，所谓的『伫列』就是排队等待其他程式使用的资料啦！ 这些资料被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中，但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中，等到被送出后就被删除。如果是工作排程资料(crontab)，就会被放置到/var/spool/cron/目录中！ |

### 目录树

![image-20200826161744454](https://tva1.sinaimg.cn/large/007S8ZIlgy1gi4abdk7v7j30u0140hdt.jpg)



## 绝对/相对路径

- 绝对路径：由根目录(/)开始写起的文件名或目录名称，例如/home/dmtsai/.bashrc；
- 相对路径：相对于目前路径的文件名写法。例如./home/dmtsai或../../home/dmtsai/等等。==反正开头不是/就属于相对路径的写法==

相对路径是以『你当前所在路径的相对位置』来表示的。举例来说，你目前在/home 这个目录下， 如果想要进入/var/log 这个目录时，可以怎么写呢？

1. cd /var/log (absolute)
2. cd ../var/log (relative)

因为你在/home 底下，所以要回到上一层(../) 之后，才能继续往/var 来移动的！特别注意这两个特殊的目录：

- . ：代表当前的目录，也可以使用./ 来表示；
- .. ：代表上一层目录，也可以../ 来代表。

这个. 与.. 目录概念是很重要的，你常常会看到cd .. 或./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态喔！很重要的呐！



# 文件、目录管理

## 目录与路径

```
. 代表此层目录
.. 代表上一层目录
- 代表前一个工作目录
~ 代表『目前使用者身份』所在的家目录
~account 代表account 这个使用者的家目录(account是个帐号名称)
```

常见的处理目录的指令：

- cd：变换目录
- pwd：显示目前的目录
- mkdir：建立一个新的目录
- rmdir：删除一个空的目录**(只能删除空目录)**

------

**cd (change directory, 变换目录)**

dmtsai这个使用者的家目录是/home/dmtsai/，而root家目录则是/root/，假设我以root身份在Linux系统中，那么简单的说明一下这几个特殊的目录的意义是：

```
[dmtsai@study ~]$ su -   #先切换身份成为root看看！
[root@study ~]# cd [相对路径或绝对路径] 
#最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！
[root@study ~]# cd ~dmtsai 
#代表去到dmtsai这个使用者的家目录，亦即/home/dmtsai 
[root@study dmtsai]# cd ~ 
#表示回到自己的家目录，亦即是/ root这个目录 
[root@study ~]# cd 
#没有加上任何路径，也还是代表回到自己家目录的意思喔！
[root@study ~]# cd .. 
#表示去到目前的上层目录，亦即是/root的上层目录的意思； 
[root@study /]# cd - 
#表示回到刚刚的那个目录，也就是/root啰～ 
[root@study ~]# cd /var/spool/mail 
#这个就是绝对路径的写法！直接指定要去的完整路径名称！
[root@study mail]# cd ../postfix
# 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/postfix 就这样写！
```

**pwd (显示目前所在的目录)**

pwd是Print Working Directory的缩写，也就是显示目前所在目录的指令

**mkdir (建立新目录)**

(make directory) 创建目录。通过 -p 来递归创建多级目录，另外，目录还有一个很重要的东西就是权限，所以需要指明权限，若没有指明就使用默认权限，这个东西就是umask。

```
[root@study ~]# mkdir [-mp]目录名称
选项与参数：
-m ：设定文件的权限喔！直接设定，不需要看预设权限(umask) 的脸色～
-p ：帮助你直接将所需要的目录(包含上层目录)递回建立起来！

范例：请到/tmp底下尝试建立数个新目录看看： 
[root@study ~]# cd /tmp 
[root@study tmp]# mkdir test     <==建立一名为test的新目录 
[root@study tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory 'test1/test2/test3/test4': No such file or directory
#话说，系统告诉我们，没可能建立这个目录啊！就是没有目录才要建立的！见鬼嘛？
[root@study tmp]# mkdir -p test1/test2/test3/test4 
#原来是要建test4上层没先建test3之故！加了这个-p的选项，可以自行帮你建立多层目录！

范例：建立权限为rwx--x--x的目录 
[root@study tmp]# mkdir -m 711 test2 
[root@study tmp]# ls -ld test*
drwxr-xr-x. 2 root root 6 Jun 4 19:03 test
drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1
drwx--x--x . 2 root root 6 Jun 4 19:05 test2
 #仔细看上面的权限部分，如果没有加上-m来强制设定属性，系统会使用预设属性。
#那么你的预设属性为何？这要透过底下介绍的umask才能了解喔！^_^
```

## 文件目录管理

文件与目录的管理上，不外乎『显示属性』、 『拷贝』、『删除文件』及『移动文件或目录』等等；

### 查看 ls

```
[root@study ~]# ls [-aAdfFhilnrRSt]文件名或目录名称.. 
[root@study ~]# ls [--color={never,auto,always}]文件名或目录名称.. 
[root@ study ~]# ls [--full-time]文件名或目录名称.. 
选项与参数：
 -a ：全部的文件，连同隐藏档(开头为.的文件)一起列出来(常用)
-A ：全部的文件，连同隐藏档，但不包括. 与.. 这两个目录
-d ：仅列出目录本身，而不是列出目录内的文件资料(常用)
-f ：直接列出结果，而不进行排序(ls 预设会以文件名排序！)
-F ：根据文件、目录等资讯，给予附加资料结构，例如：
      *:代表可执行档； /:代表目录； =:代表socket 文件； |:代表FIFO 文件；
-h ：将文件容量以人类较易读的方式(例如GB, KB 等等)列出来；
-i ：列出inode 号码，inode 的意义下一章将会介绍；
-l ：长资料串列出，包含文件的属性与权限等等资料；(常用)
-n ：列出UID 与GID 而非使用者与群组的名称(UID与GID会在帐号管理提到！)
-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；
-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；
-S ：以文件容量大小排序，而不是用文件名排序；
-t ：依时间排序，而不是用文件名。
--color=never ：不要依据文件特性给予颜色显示；
--color=always ：显示颜色
--color=auto ：让系统自行依据设定来判断是否给予颜色
--full-time ：以完整时间模式(包含年、月、日、时、分) 输出
--time={atime,ctime} ：输出access 时间或改变权限属性时间(ctime) 
                       而非内容变更时间(modification time)
```



`ls -al --full-time ; ls -al ~`

### 复制、删除、移动

复制

```
[root@study ~]# cp [-adfilprsu]来源档(source)目标档(destination) 
[root@study ~]# cp [options] source1 source2 source3 .... directory 
选项与参数：
 -a ：相当于-dr --preserve=all的意思，至于dr请参考下列说明；(常用)
-d ：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
-f ：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
-i ：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
-l ：进行硬式连结(hard link)的连结档建立，而非复制文件本身；
-p ：连同文件的属性(权限、用户、时间)一起复制过去，而非使用预设属性(备份常用)；
-r ：递回持续复制，用于目录的复制行为；(常用)
-s ：复制成为符号连结档(symbolic link)，亦即『捷径』文件；
-u ：destination 比source 旧才更新destination，或destination 不存在的情况下才复制。
--preserve=all ：除了-p 的权限相关参数外，还加入SELinux 的属性, links, xattr 等也复制了。
最后需要注意的，如果来源档有两个以上，则最后一个目的档一定要是『目录』才行！
```

删除

```
root@study ~]# rm [-fir]文件或目录
选项与参数：
-f ：就是force 的意思，忽略不存在的文件，不会出现警告讯息；
-i ：互动模式，在删除前会询问使用者是否动作
-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！

范例一：将刚刚在cp的范例中建立的bashrc删除掉！
[root@study ~]# cd /tmp 
[root@study tmp]# rm -i bashrc 
rm: remove regular file `bashrc'? y 
#如果加上-i的选项就会主动询问喔，避免你删除到错误的文件名！

范例二：透过万用字符*的帮忙，将/tmp底下开头为bashrc的文件名通通删除： 
[root@study tmp]# rm -i bashrc* 
#注意那个星号，代表的是0到无穷多个任意字符喔！很好用的东西！

范例三：将cp范例中所建立的/tmp/etc/这个目录删除掉！
[root@study tmp]# rmdir /tmp/etc 
rmdir: failed to remove '/tmp/etc': Directory not empty    <==删不掉啊！因为这不是空的目录！
[root@study tmp]# rm -r /tmp/etc 
rm: descend into directory `/tmp/etc'? y 
rm: remove regular file `/tmp/etc/fstab'? y 
rm: remove regular empty file `/ tmp/etc/crypttab'? ^C   <==按下[ctrl]+c中断
.....(中间省略).....
# 因为身份是root ，预设已经加入了-i 的选项，所以你要一直按y 才会删除！
# 如果不想要继续按y ，可以按下『 [ctrl]-c 』来结束rm 的工作。
#这是一种保护的动作，如果确定要删除掉此目录而不要询问，可以这样做： 
[root@study tmp]# \rm -r /tmp/etc 
#在指令前加上反斜线，可以忽略掉alias的指定选项喔！至于alias我们在bash再谈！
# 拜托！这个范例很可怕！你不要删错了！删除/etc 系统是会挂掉的！
```

移动

```
[root@study ~]# mv [-fiu] source destination 
[root@study ~]# mv [options] source1 source2 source3 .... directory 
选项与参数：
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
-i ：若目标文件(destination) 已经存在时，就会询问是否覆盖！
-u ：若目标文件已经存在，且source 比较新，才会更新(update)

范例一：复制一文件，建立一目录，将文件移动到目录中 
[root@study ~]# cd /tmp 
[root@study tmp]# cp ~/.bashrc bashrc 
[root@study tmp]# mkdir mvtest 
[ root@study tmp]# mv bashrc mvtest 
#将某个文件移动到某个目录去，就是这样做！

范例二：将刚刚的目录名称更名为mvtest2 
[root@study tmp]# mv mvtest mvtest2  <==这样就更名了！简单～
#其实在Linux底下还有个有趣的指令，名称为rename，
# 该指令专职进行多个文件名的同时更名，并非针对单一文件名变更，与mv不同。请man rename。

范例三：再建立两个文件，再全部移动到/tmp/mvtest2当中 
[root@study tmp]# cp ~/.bashrc bashrc1 
[root@study tmp]# cp ~/.bashrc bashrc2 
[root@study tmp] # mv bashrc1 bashrc2 mvtest2 
#注意到这边，如果有多个来源文件或目录，则最后一个目标档一定是『目录！』
# 意思是说，将所有的资料移动到该目录的意思！
```

## 查看文档内容

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出tac 是cat 的倒着写！
- nl 显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与more 类似，但是比more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行
- od 以二进位的方式读取文件内容！

然后还有一些查找的窍门技巧如下：

**翻页查找**：more、less

进入翻页模式后，输入/ 用q 离开，即可。

**数据截取**：head、tail (从头和从尾截取)

`head/tail  [-n number] fileName`

```
root@study ~]# head [-n number]文件
选项与参数：
-n ：后面接数字，代表显示几行的意思

[root@study ~]# head /etc/man_db.conf 
#预设的情况中，显示前面十行！若要显示前20行，就得要这样： 
[root@study ~]# head -n 20 /etc/man_db.conf
```

比如说我想截取某个文件的第10行到20行；

可以运用命令 `head -n  20  fileName | tail -n 10`  这样就可以了。这里的 ｜ 是管道操作命令。

### 修改文件时间或创建文件Touch

 touch 这个指令最常被使用的情况是：

- 建立一个空的文件；
- 将某个文件日期修订为目前(mtime 与atime)

一般的，文件有多个时间，修改时间、状态时间、读取时间；

- **modification time (mtime)**：
  当该文件的『内容资料』变更时，就会更新这个时间！内容资料指的是文件的内容，而不是文件的属性或权限喔！
- **status time (ctime)**：
  当该文件的『状态(status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。
- **access time (atime)**：
  当『该文件的内容被取用』时，就会更新这个读取时间(access)。举例来说，我们使用cat去读取/etc/man_db.conf ，就会更新该文件的atime了。

ls命令显示出来的是该文件的mtime ，也就是这个文件的内容上次被更动的时间。

```
[root@study ~]# touch [-acdmt]文件
选项与参数：
-a ：仅修订access time；
-c ：仅修改文件的时间，若该文件不存在则不建立新文件；
-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用--date="日期或时间"
-m ：仅修改mtime ；
-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]

范例一：新建一个空的文件并观察时间 
[dmtsai@study ~]# cd /tmp 
[dmtsai@study tmp]# touch testtouch 
[dmtsai@study tmp]# ls -l testtouch 
-rw-rw-r--. 1 dmtsai dmtsai 0 Jun 16 00:45 testtouch
 #注意到，这个文件的大小是0呢！在预设的状态下，如果touch后面有接文件，
# 则该文件的三个时间(atime/ctime/mtime) 都会更新为目前的时间。若该文件不存在，
# 则会主动的建立一个新的空的文件喔！例如上面这个例子！

范例二：将~/.bashrc复制成为bashrc，假设复制完全的属性，检查其日期 
[dmtsai@study tmp]# cp -a ~/.bashrc bashrc 
[dmtsai@study tmp]# date; ll bashrc; ll - -time=atime bashrc; ll --time=ctime bashrc 
Tue Jun 16 00:49:24 CST 2015                          <==这是目前的时间 
-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 bashrc   <==这是mtime 
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15 23:44 bashrc   <==这是atime 
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00 :47 bashrc   <==这是ctime
```

在上面这个案例当中我们使用了『ll』这个指令(两个英文L的小写)，这个指令其实就是『ls -l』的意思， ll本身不存在，是被『做出来』的一个命令别名。这里先知道ll="ls -l"即可。至于分号『 ; 』则代表连续指令的下达啦！你可以在一行指令当中写入多重指令，这些指令可以『依序』执行。由上面的指令我们会知道ll那一行有三个指令被下达在同一行中。

## 文件默认权限和隐藏权限

文件的权限有读写执行（rwx），以及是否是目录、文件或者链接属性。单纯的读写执行权限无法满足我们的基本要求，因此对应有了特殊权限位（SUID、SGID、SBIT），这些权限 位用来弥补一般权限不能实现的功能，帮助没有权限的用户执行需要root权限的工作。

### 文件默认权限 umask

当你建立一个新的文件或目录时，他的预设权限会是什么吗？呵呵！那就与umask这个玩意儿有关了！那么umask是在搞什么呢？

**在预设权限的属性上，目录与文件是不一样的**。从第五章我们知道x 权限对于目录是非常重要的！但是一般文件的建立则不应该有执行的权限，因为一般文件通常是用在于资料的记录嘛！当然不需要执行的权限了。因此，预设的情况如下：

- 若使用者建立为『文件』则预设『没有可执行( x )权限』，亦即只有rw这两个项目，也就是最大为666分，预设权限如下：
  **-rw-rw-rw-**
- 若使用者建立为『目录』，则由于x与是否可以进入此目录有关，因此预设为所有权限均开放，亦即为777分，预设权限如下：
  **drwxrwxrwx**

注意的是，umask的分数指的是『该预设值需要减掉的权限！』,r、w、x分别是4、2、1分, 当我们运行 umask ，会得到一个分数

```
shijianhua@sjh-MacPro resume % umask
022
shijianhua@sjh-MacPro resume % umask -S
u=rwx,g=rx,o=rx
```

就是 666/777 （根据是文件或目录）减去这个umask 所显示的分数。

以上面的例子来说明的话，因为umask 为022 ，所以user 并没有被拿掉任何权限，不过group 与others 的权限被拿掉了2 (也就是w 这个权限)，那么当使用者：

- 建立文件时：(-rw-rw-rw-) - (-----w--w-) ==> -rw-r--r--
- 建立目录时：(drwxrwxrwx) - (d----w--w-) ==> drwxr-xr-x

### 文件特殊权限

SUID、SGID、DBIT

具体内容可以看 http://linux.vbird.org/linux_basic/0220filemanager.php

## 文件查找

### which 脚本文件

which 可以找出在PATH 配置了环境变量的文件命令。即这个指令是根据『[PATH](http://linux.vbird.org/linux_basic/0220filemanager.php#dir_path)』这个环境变量所规范的路径，去搜寻『执行文件』的文件名

```
[root@study ~]# which [-a] command 
选项或参数：
-a ：将所有由PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称

范例一：搜寻ifconfig这个指令的完整文件名 
[root@study ~]# which ifconfig
/sbin/ifconfig 

范例二：用which去找出which的文件名为何？
[root@study ~]# which which
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
        /bin/alias
        /usr/bin/which
# 竟然会有两个which ，其中一个是alias 这玩意儿呢！那是啥？
# 那就是所谓的『命令别名』，意思是输入which 会等于后面接的那串指令啦！
# 更多的资料我们会在bash 章节中再来谈的！

范例三：请找出history这个指令的完整文件名 
[root@study ~]# which history
/usr/bin/which: no history in (/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin:/root/bin)
```

### 文件查找

**whereis (由一些特定的目录中寻找文件文件名)**

由于whereis 只会在特定的目录，针对/bin /sbin 底下的执行文件， 以及/usr/share/man 底下的man page 文件；

```
[root@study ~]# whereis [-bmsu]文件或目录名
选项与参数：
-l :可以列出whereis 会去查询的几个主要目录而已
-b :只找binary 格式的文件
-m :只找在说明档manual 路径下的文件
-s :只找source 来源文件
-u :搜寻不在上述三个项目当中的其他特殊文件

范例一：请找出ifconfig这个文件名 
[root@study ~]# whereis ifconfig
ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz

范例二：只找出跟passwd有关的『说明文件』文件名(man page) 
[root@study ~]# whereis passwd      #全部的文件名通通列出来！
passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
[root@study ~]# whereis -m passwd   #只有在man里面的文件名才抓出来！
passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
```

**locate / updatedb**

```
[root@study ~]# locate [-ir] keyword 
选项与参数：
-i ：忽略大小写的差异；
-c ：不输出文件名，仅计算找到的文件数量
-l ：仅输出几行的意思，例如输出五行则是-l 5
-S ：输出locate 所使用的资料库文件的相关资讯，包括该资料库纪录的文件/目录数量等
-r ：后面可接正则表达式的显示方式

范例一：找出系统中所有与passwd相关的文件名，且只列出5个 
[root@study ~]# locate -l 5 passwd
/etc/passwd
/etc/passwd-
/etc/pam.d/passwd
/etc/security/opasswd
/usr/bin/gpasswd

范例二：列出locate查询所使用的资料库文件之文件名与各资料数量 
[root@study ~]# locate -S
Database /var/lib/mlocate/mlocate.db:
        8,086 directories      #总纪录目录数 
        109,605 files          #总纪录文件数
        5,190,295 bytes in file names
        2,349,150 bytes used to store database
```

locate 的使用更简单，直接在后面输入『文件的部分名称』后，就能够得到结果。举上面的例子来说，我输入locate passwd ，那么在完整文件名(包含路径名称) 当中，只要有passwd 在其中， 就会被显示出来的；

使用locate来寻找资料的时候特别的快，这是因为locate寻找的资料是由『已建立的资料库/var/lib/mlocate/』里面的资料所搜寻到的，所以不用直接在去硬碟当中存取资料！

​     有什么限制呢？就是因为他是经由资料库来搜寻的，而资料库的建立预设是在每天执行一次(每个distribution 都不同，CentOS 7.x 是每天更新资料库一次！)，所以当你新建立起来的文件， 却还在资料库更新之前搜寻该文件，那么locate 会告诉你『找不到！』！因为必须要更新资料库呀！

那能否手动更新资料库哪？当然可以啊！更新locate 资料库的方法非常简单，直接输入『 updatedb 』就可以了！updatedb 指令会去读取/etc/updatedb.conf 这个设定档的设定，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个资料库文件啰！因为updatedb 会去搜寻硬盘，所以当你执行updatedb 时，可能会等待数分钟的时间喔！

- updatedb：根据/etc/updatedb.conf 的设定去搜寻系统硬碟内的文件名，并更新/var/lib/mlocate 内的资料库文件；
- locate：依据/var/lib/mlocate 内的资料库记载，找出使用者输入的关键字文件名。

**find**

```
[root@study ~]# find [PATH] [option] [action] 
选项与参数：
1. 与时间有关的选项：共有-atime, -ctime 与-mtime ，以-mtime 说明
   -mtime n ：n 为数字，意义为在n 天之前的『一天之内』被更动过内容的文件；
   -mtime +n ：列出在n 天之前(不含n 天本身)被更动过内容的文件文件名；
   -mtime -n ：列出在n 天之内(含n 天本身)被更动过内容的文件文件名。
   -newer file ：file 为一个存在的文件，列出比file 还要新的文件文件名

范例一：将过去系统上面24小时内有更动过内容(mtime)的文件列出 
[root@study ~]# find / -mtime 0 
#那个0是重点！0代表目前的时间，所以，从现在开始到24小时前，
# 有变动过内容的文件都会被列出来！那如果是三天前的24 小时内？
# find / -mtime 3 有变动过的文件都被列出的意思！

范例二：寻找/etc底下的文件，如果文件日期比/etc/passwd新就列出 
[root@study ~]# find /etc -newer /etc/passwd 
# -newer用在分辨两个文件之间的新旧关系是很有用的！
```

知道atime, ctime与mtime的意义，如果你想要找出一天内被更动过的文件名称，可以使用上述范例一的作法。但如果我想要找出『4天内被更动过的文件文件名』呢？那可以使用『 find /var -mtime -4』。那如果是『4天前的那一天』就用『 find /var -mtime 4』。有没有加上『+, -』差别很大喔！我们可以用简单的图示来说明一下：



![find 相关的时间参数意义](https://tva1.sinaimg.cn/large/007S8ZIlgy1gi5owqr6org309t035jr6.gif)

图6.5.1、find 相关的时间参数意义

图中最右边为目前的时间，越往左边则代表越早之前的时间轴啦。由图6.5.1 我们可以清楚的知道：

- +4代表大于等于5天前的文件名：ex> find /var -mtime +4
- -4代表小于等于4天内的文件文件名：ex> find /var -mtime -4
- 4则是代表4-5那一天的文件文件名：ex> find /var -mtime 4

其他find 的用法：

```
选项与参数：
2. 与使用者或群组名称有关的参数：
   -uid n ：n 为数字，这个数字是使用者的帐号ID，亦即UID ，这个UID 是记录在
            /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。
   -gid n ：n 为数字，这个数字是群组名称的ID，亦即GID，这个GID 记录在
            /etc/group，相关的介绍我们会第四篇说明～
   -user name ：name 为使用者帐号名称喔！例如dmtsai
   -group name：name 为群组名称喔，例如users ；
   -nouser ：寻找文件的拥有者不存在/etc/passwd 的人！
   -nogroup ：寻找文件的拥有群组不存在于/etc/group 的文件！
                当你自行安装软体时，很可能该软体的属性当中并没有文件拥有者，
                这是可能的！在这个时候，就可以使用-nouser 与-nogroup 搜寻。

范例三：搜寻/home底下属于dmtsai的文件 
[root@study ~]# find /home -user dmtsai 
#这个东西也很有用的～当我们要找出任何一个使用者在系统当中的所有文件时，
# 就可以利用这个指令将属于某个使用者的所有文件都找出来喔！

范例四：搜寻系统中不属于任何人的文件 
[root@study ~]# find / -nouser 
#透过这个指令，可以轻易的就找出那些不太正常的文件。如果有找到不属于系统任何人的文件时，
# 不要太紧张，那有时候是正常的～尤其是你曾经以原始码自行编译软体时。
```

## 复习

一、让使用者能进入某目录成为『可工作目录』的基本权限为何：

- 可使用的指令：例如cd 等变换工作目录的指令；
- 目录所需权限：使用者对这个目录至少需要具有x的权限
- 额外需求：如果使用者想要在这个目录内利用ls 查阅文件名，则使用者对此目录还需要r 的权限。

二、使用者在某个目录内读取一个文件的基本权限为何？

- 可使用的指令：例如本章谈到的cat, more, less等等
- 目录所需权限：使用者对这个目录至少需要具有x 权限；
- 文件所需权限：使用者对文件至少需要具有r的权限才行！

三、让使用者可以修改一个文件的基本权限为何？

- 可使用的指令：例如[nano](http://linux.vbird.org/linux_basic/0160startlinux.php#nano)或未来要介绍的[vi](http://linux.vbird.org/linux_basic/0310vi.php)编辑器等；
- 目录所需权限：使用者在该文件所在的目录至少要有x 权限；
- 文件所需权限：使用者对该文件至少要有r, w权限

四、让一个使用者可以建立一个文件的基本权限为何？

- 目录所需权限：使用者在该目录要具有w,x的权限，重点在w啦！

五、让使用者进入某目录并执行该目录下的某个指令之基本权限为何？

- 目录所需权限：使用者在该目录至少要有x 的权限；
- 文件所需权限：使用者在该文件至少需要有x 的权限

------

**其他的知识点**

- 绝对路径：『一定由根目录/ 写起』；相对路径：『不由/ 写起，而是由相对当前目录写起』
- 特殊目录有：., .., -, ~, ~account需要注意；
- 与目录相关的指令有：cd, mkdir, rmdir, pwd 等重要指令；
- rmdir 仅能删除空目录，要删除非空目录需使用『 rm -r 』指令；
- 使用者能使用的指令是依据PATH 变量所规定的目录去搜寻的；
- ls 可以检视文件的属性，尤其-d, -a, -l 等选项特别重要！
- 文件的复制、删除、移动可以分别使用：cp, rm , mv等指令来操作；
- 检查文件的内容(读档)可使用的指令包括有：cat, tac, nl, more, less, head, tail, od 等
- cat -n 与nl 均可显示行号，但预设的情况下，空白行会不会编号并不相同；
- touch 的目的在修改文件的时间参数，但亦可用来建立空文件；
- 一个文件记录的时间参数有三种，分别是access time(atime), status time (ctime), modification time(mtime)，ls 预设显示的是mtime。
- 除了传统的rwx权限之外，在Ext2/Ext3/Ext4/xfs文件系统中，还可以使用chattr与lsattr设定及观察隐藏属性。常见的包括只能新增资料的+a 与完全不能更动文件的+i 属性。
- 新建文件/目录时，新文件的预设权限使用umask 来规范。预设目录完全权限为drwxrwxrwx， 文件则为-rw-rw-rw-。
- 文件具有SUID的特殊权限时，代表当使用者执行此一binary程序时，在执行过程中使用者会暂时具有程序拥有者的权限
- 目录具有SGID的特殊权限时，代表使用者在这个目录底下新建的文件之群组都会与该目录的群组名称相同。
- 目录具有SBIT的特殊权限时，代表在该目录下使用者建立的文件只有自己与root能够删除！
- 观察文件的类型可以使用file 指令来观察；
- 搜寻指令的完整文件名可用which 或type ，这两个指令都是透过PATH 变量来搜寻文件名；
- 搜寻文件的完整文件名可以使用whereis 找特定目录或locate 到资料库去搜寻，而不实际搜寻文件系统；
- 利用find 可以加入许多选项来直接查询文件系统，以获得自己想要知道的文件名；

# Linux 压缩

在Linux的环境中，压缩文件的副文件名大多是：『*.tar, *.tar.gz, *.tgz, *.gz, *.Z, *.bz2, *.xz』，Linux 支持的压缩指令非常多，且不同的指令所用的压缩技术并不相同。且各个压缩所用的原理不同

```
*.Z compress 程序压缩的文件；
*.zip zip 程序压缩的文件；
*.gz gzip 程序压缩的文件；
*.bz2 bzip2 程序压缩的文件；
*.xz xz 程序压缩的文件；
*.tar tar 程序打包的资料，并没有压缩过；
*.tar.gz tar 程序打包的文件，其中并且经过gzip 的压缩
*.tar.bz2 tar 程序打包的文件，其中并且经过bzip2 的压缩
*.tar.xz tar 程序打包的文件，其中并且经过xz 的压缩
```

Linux上常见的压缩指令就是gzip, bzip2。还有兼容windows的zip。说说这个tar，这个tar没有压缩功能，只是打包功能，把众多的文件夹打包到一起，然后再用zip去压缩，所以说有了tar.zip 这样的后缀名。

```
[dmtsai@study ~]$ gzip [-cdtv#]文件名 
[dmtsai@study ~]$ zcat文件名.gz 
选项与参数：
-c ：将压缩的资料输出到萤幕上，可透过资料流重导向来处理；
-d ：解压缩的参数；
-t ：可以用来检验一个压缩档的一致性～看看文件有无错误；
-v ：可以显示出原文件/压缩文件的压缩比等资讯；
-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是-6
```

Mac 系统没有gzip这个命令，在linux中，使用该命令会使之前的文件消失，变成后缀名为.gz 的文件。然后可以通过zcat/zmore/zless 去查看压缩后的文件，也可以用 -d 来还原成之前的文件。

另外，bzip2 提供了更高的压缩比，使用和gzip是一样的，后缀名为.bz2 ;

## Tar 指令

上面谈到的指令大多仅能针对单一文件来进行压缩，虽然gzip, bzip2, xz也能够针对目录来进行压缩，不过，这两个指令对目录的压缩指的是『将目录内的所有文件"分别"进行压缩』的动作！而不像在Windows的系统，可以使用类似[WinRAR](http://www.rar.com.tw/)这一类的压缩软件来将好多资料『包成一个文件』的样式。

```
[dmtsai@study ~]$ tar [-z|-j|-J] [cv] [-f待建立的新文件名] filename...  <==打包与压缩 
[dmtsai@study ~]$ tar [ -z|-j|-J] [tv] [-f既有的tar文件名]              <==察看文件名 
[dmtsai@study ~]$ tar [-z|-j|-J] [xv] [ -f既有的tar文件名] [-C目录]    <==解压缩
选项与参数：
-c ：建立打包文件，可搭配-v 来察看过程中被打包的文件名(filename)
-t ：察看打包文件的内容含有哪些文件名，重点在察看『文件名』就是了；
-x ：解打包或解压缩的功能，可以搭配-C (大写) 在特定目录解开
      特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。
-z ：透过gzip 的支援进行压缩/解压缩：此时文件名最好为*.tar.gz
-j ：透过bzip2 的支援进行压缩/解压缩：此时文件名最好为*.tar.bz2
-J ：透过xz 的支援进行压缩/解压缩：此时文件名最好为*.tar.xz
      特别留意， -z, -j, -J 不可以同时出现在一串指令列中
-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！
-f filename：-f 后面要立刻接要被处理的文件名！建议-f 单独写一个选项啰！(比较不会忘记)
-C 目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。

其他后续练习会使用到的选项介绍：
-p(小写) ：保留备份资料的原本权限与属性，常用于备份(-c)重要的设定档
-P(大写) ：保留绝对路径，亦即允许备份资料中含有根目录存在之意；
--exclude=FILE：在压缩的过程中，不要将FILE 打包！ 
```

其实最简单的使用tar 就只要记忆底下的方式即可（以bzip2方式为准）：

- 压缩：tar -jcv -f filename.tar.bz2  file 

  > filename.tar.bz2是压缩后的文件名，file 是要被压缩的文件名或目录名称；
  >
  > eg：tar -jtv -f sjh.tar.bz2  sjh  这个sjh是当前目录下的文件，可以用相对路径或绝对路径。

- 查询：tar -jtv -f  filename.tar.bz2

- 解压缩：tar -jxv  -f  filename.tar.bz2  -C  + ==欲解压缩的目录== （这个目录是一个参数，不是解释语）

# Vi 编辑器

vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器。掌握vi 是很有bi很有必要的；

## vi的使用

基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。

**1) 命令行模式command mode）**

控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。

  **2) 插入/编辑模式（Insert mode）**

只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。

  **3) 底行模式（last line mode）**

将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。

这三种模式相互转换的方式如下：

![image-20200905213056212](https://tva1.sinaimg.cn/large/007S8ZIlgy1gig3kc8mkwj30r20cw41e.jpg)

图中的一般指令模式——命令行模式，这个模式可以做的操作是最多的，也是最复杂的，快捷键也是最多的；

指令列命令模式——底行模式（因为会把光标放到底行，所以就叫底行模式），主要是文件退出保存、寻找字符串、显示行号；

**编辑模式和底行模式不能转换，必须经过命令行模式进行转换。**

## 命令行命令

#### 进入vi

`vi fileName `

#### 移动光标

| 移动游标的方法                                               |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| h 或向左方向键(←)                                            | 游标向左移动一个字符                                         |
| j 或向下方向键(↓)                                            | 游标向下移动一个字符                                         |
| k 或向上方向键(↑)                                            | 游标向上移动一个字符                                         |
| l 或向右方向键(→)                                            | 游标向右移动一个字符                                         |
| 如果你将右手放在键盘上的话，你会发现hjkl 是排列在一起的，因此可以使用这四个按钮来移动游标。如果想要进行多次移动的话，例如向下移动30 列，可以使用"30j" 或"30↓" 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ |                                                              |
| [Ctrl] + [f]                                                 | 萤幕『向下』移动一页，相当于[Page Down]按键( 常用 )          |
| [Ctrl] + [b]                                                 | 萤幕『向上』移动一页，相当于[Page Up]按键( 常用 )            |
| [Ctrl] + [d]                                                 | 萤幕『向下』移动半页                                         |
| [Ctrl] + [u]                                                 | 萤幕『向上』移动半页                                         |
| n<space>                                                     | 那个n 表示『数字』，例如20 。按下数字后再按空白键，游标会向右移动这一列的n 个字符。例如20<space> 则游标会向后面移动20 个字符距离。 |
| 0 或功能键[Home]                                             | 这是数字『 0 』：移动到这一列的最前面字符处( 常用 )          |
| $ 或功能键[End]                                              | 移动到这一列的最后面字符处( 常用 )                           |
| G                                                            | 移动到这个文件的最后一列( 常用 )                             |
| gg                                                           | 移动到这个文件的第一列，相当于1G啊！( 常用 )                 |
| n<Enter>                                                     | n为数字。游标向下移动n列( 常用 )                             |

#### 删除、复制与贴上

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| x, X     | 在一列字当中，x为向后删除一个字符(相当于[del]按键)， X为向前删除一个字符(相当于[backspace]亦即是倒退键) ( 常用 ) |
| nx       | n 为数字，连续向后删除n 个字符。举例来说，我要连续删除10 个字符， 『10x』。 |
| dd       | 删除游标所在的那一整列( 常用 )                               |
| ndd      | n为数字。删除游标所在的向下n列，例如20dd则是删除20列( 常用 ) |
| yy       | 复制游标所在的那一列( 常用 )                                 |
| nyy      | n为数字。复制游标所在的向下n列，例如20yy则是复制20列( 常用 ) |
| p, P     | p为将已复制的资料在游标下一列贴上，P则为贴在游标上一列！举例来说，我目前游标在第20列，且已经复制了10列资料。则按下p后，那10列资料会贴在原本的20列之后，亦即由21列开始贴。但如果是按下P呢？那么原本的第20列会被推到变成30列。( 常用 ) |
| u        | 复原前一个动作。( 常用 )                                     |
| [Ctrl]+r | 重做上一个动作。( 常用 )                                     |
|          | 这个u 与[Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ |
| .        | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！( 常用 ) |

#### 搜寻与取代

|                       |                                                              |
| --------------------- | ------------------------------------------------------------ |
| /word                 | 向游标之下寻找一个名称为word的字串。例如要在文件内搜寻vbird这个字串，就输入/vbird即可！( 常用 ) |
| ?word                 | 向游标之上寻找一个字串名称为word 的字串。                    |
| n                     | 这个n是英文按键。代表『重复前一个搜寻的动作』。举例来说，如果刚刚我们执行/vbird去向下搜寻vbird这个字串，则按下n后，会向下继续搜寻下一个名称为vbird的字串。如果是执行?vbird的话，那么按下n则会向上继续搜寻名称为vbird的字串！ |
| N                     | 这个N 是英文按键。与n 刚好相反，为『反向』进行前一个搜寻动作。例如/vbird 后，按下N 则表示『向上』搜寻vbird 。 |
| :n1,n2s/word1/word2/g | n1与n2为数字。在第n1与n2列之间寻找word1这个字串，并将该字串取代为word2 ！举例来说，在100到200列之间搜寻vbird并取代为VBIRD则： 『:100,200s/vbird/VBIRD/g』。( 常用 ) |
| :1,$s/word1/word2/g   | 从第一列到最后一列寻找word1字串，并将该字串取代为word2 ！( 常用 ) |
| :1,$s/word1/word2/gc  | 从第一列到最后一列寻找word1字串，并将该字串取代为word2 ！且在取代前显示提示字符给使用者确认(confirm)是否需要取代！( 常用 ) |

**使用/word 配合n 及N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键字！**



## 编辑模式

|       | 进入插入或取代的编辑模式                                     |
| ----- | ------------------------------------------------------------ |
| i, I  | 进入插入模式(Insert mode)： i为『从目前游标所在处插入』， I为『在目前所在列的第一个非空白字符处开始插入』。( 常用 ) |
| a, A  | 进入插入模式(Insert mode)： a为『从目前游标所在的下一个字符处开始插入』， A为『从游标所在列的最后一个字符处开始插入』。( 常用 ) |
| o, O  | 进入插入模式(Insert mode)： 这是英文字符o的大小写。o为『在目前游标所在的下一列处插入新的一列』； O为在目前游标所在处的上一列插入新的一列！( 常用 ) |
| r, R  | 进入取代模式(Replace mode)： r只会取代游标所在的那一个字符一次；R会一直取代游标所在的文字，直到按下ESC为止；( 常用 ) |
|       | 上面这些按键中，在vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到INSERT 或REPLACE 才能输入喔！ |
| [Esc] | 退出编辑模式，回到一般指令模式中( 常用 )                     |

其实用 i 、a 、 o 都差不多。

## 底行模式

|                    | 指令列模式的储存、离开等指令                                 |
| ------------------ | ------------------------------------------------------------ |
| :w                 | 将编辑的资料写入硬碟文件中( 常用 )                           |
| :w!                | 若文件属性为『唯读』时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！ |
| :q                 | 离开vi ( 常用 )                                              |
| :q!                | 若曾修改过文件，又不想储存，使用! 为强制离开不储存文件。     |
| :wq                | 储存后离开，若为:wq!则为强制储存后离开( 常用 )               |
| ZZ                 | 这是大写的Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！ |
| :w [filename]      | 将编辑的资料储存成另一个文件（类似另存新档）                 |
| :r [filename]      | 在编辑的资料中，读入另一个文件的资料。亦即将『filename』 这个文件内容加到游标所在列后面 |
| **vim 环境的变更** |                                                              |
| :set nu            | 显示行号，设定之后，会在每一列的字首显示该列的行号           |
| :set nonu          | 与set nu 相反，为取消行号！                                  |

- 注意一下啊，那个惊叹号(!) 在vi 当中，常常具有『强制』的意思～
- w 和wq 这两个比较常用；



![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gig6ae7u3tj30ku0a93z4.jpg)



## vim 的环境设定参数

我们还可以设置vi编辑器的特定设置，就像androidStudio 类似的编辑器，设置行号，颜色等，我们不想每次都给文档设置一遍，就可以修改vi的设置文件来达到这个目录，这个东西可以参考 http://linux.vbird.org/linux_basic/0310vi.php ；

|                                   | vim 的环境设定参数                                           |
| --------------------------------- | ------------------------------------------------------------ |
| :set nu :set nonu                 | 就是设定与取消行号啊！                                       |
| :set hlsearch :set nohlsearch     | hlsearch 就是high light search(高亮度搜寻)。这个就是设定是否将搜寻的字串反白的设定值。预设值是hlsearch |
| :set autoindent :set noautoindent | 是否自动缩排？autoindent 就是自动缩排。                      |
| :set backup                       | 是否自动储存备份档？一般是nobackup 的， 如果设定backup 的话，那么当你更动任何一个文件时，则原始文件会被另存成一个文件名为filename~ 的文件。举例来说，我们编辑hosts ，设定:set backup ，那么当更动hosts 时，在同目录下，就会产生hosts~ 文件名的文件，记录原始的hosts 文件内容 |
| :set ruler                        | 还记得我们提到的右下角的一些状态列说明吗？这个ruler 就是在显示或不显示该设定值的啦！ |
| :set showmode                     | 这个则是，是否要显示--INSERT-- 之类的字眼在左下角的状态列。  |
| :set backspace=(012)              | 一般来说， 如果我们按下i 进入编辑模式后，可以利用倒退键(backspace) 来删除任意字符的。但是，某些distribution 则不许如此。此时，我们就可以透过backspace 来设定啰～ 当backspace 为2 时，就是可以删除任意值；0 或1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！ |
| :set all                          | 显示目前所有的环境参数设定值。                               |
| :set                              | 显示与系统预设值不同的设定参数， 一般来说就是你有自行变动过的设定参数啦！ |
| :syntax on :syntax off            | 是否依据程序相关语法显示不同颜色？举例来说，在编辑一个纯文字档时，如果开头是以# 开始，那么该列就会变成蓝色。如果你懂得写程序，那么这个:syntax on 还会主动的帮你除错呢！但是， 如果你仅是编写纯文字文件，要避免颜色对你的萤幕产生的干扰，则可以取消这个设定。 |
| :set bg=dark :set bg=light        | 可用以显示不同的颜色色调，预设是『 light 』。如果你常常发现注解的字体深蓝色实在很不容易看， 那么这里可以设定为dark 喔！试看看，会有不同的样式呢！ |

## 重点回顾

- Linux 底下的设定档多为文字档，故使用vim 即可进行设定编辑；
- vim 可视为程序编辑器，可用以编辑shell script, 设定档等，避免打错字；
- vi 为所有unix like 的作业系统都会存在的编辑器，且执行速度快速；
- vi 有三种模式，一般指令模式可变换到编辑与指令列模式，但编辑模式与指令列模式不能互换；
- 常用的按键有i, [Esc], :wq 等；
- vi 的画面大略可分为两部份，(1)上半部的本文与(2)最后一行的状态+指令列模式；
- 数字是有意义的，用来说明重复进行几次动作的意思，如5yy 为复制5 列之意；
- 游标的移动中，大写的G 经常使用，尤其是1G, G 移动到文章的头/尾功能！
- vi 的取代功能也很棒！:n1,n2s/old/new/g 要特别注意学习起来；
- 小数点『 . 』为重复进行前一次动作，也是经常使用的按键功能！
- 进入编辑模式几乎只要记住： i, o, R 三个按钮即可！尤其是新增一列的o 与取代的 R
- vim 会主动的建立swap 暂存档，所以不要随意断线！
- 如果在文章内有对齐的区块，可以使用[ctrl]-v 进行复制/贴上/删除的行为
- 使用:sp 功能可以分割视窗
- 若使用vim 来撰写网页，若需要CSS 元素资料，可透过[ctrl]+x, [ctrl]+o 这两个连续组合按键来取得关键字
- vim 的环境设定可以写入在~/.vimrc 文件中；
- 可以使用iconv 进行文件语系编码的转换
- 使用dos2unix 及unix2dos 可以变更文件每一列的行尾断行字符。



# BASH

## 什么是bash

我们知道操作系统是连接软件和硬件的中间桥梁，把面向用户的桌面软件的指令转换为系统指令，在到汇编语言给底层硬件，到最终执行。假如我们想要和操作系统打交道，就需要借助一些桌面软件（比如shell），而Bash就是这些桌面软件的一种，这样说就明白了。桌面软件也称为壳程序，还有其他的 比如 man、chmod、chown等这些命令后面隐藏的程序。

### 系统的shell

由于早年的Unix年代，发展者众，所以由于shell依据发展者的不同就有许多的版本，例如常听到的Bourne SHell (sh) 、在Sun里头预设的C SHell、商业上常用的K SHell、 ,还有TCSH等等，每一种Shell都各有其特点。至于Linux使用的这一种版本就称为『 Bourne Again SHell (简称bash) 』。所以有众多的shell版本，通常我们就使用Bash这个版本。

==学习完这个bash 后，你就能明白之前学习到了很多命令是怎么回事？还有哪些其他的高级用法，你可以对这些命令做到心中有数、分类，甚至洞察他们的本质，在理解层面高一个层次。==

### Bash shell 功能

- 历史命令

  > 可以记录使用过的命令，而这些命令存在.bash_history 中

- 命令和文文件名补全 （tab键的强大）

  > - [Tab] 接在一串指令的第一个字的后面，则为命令补全；
  > - [Tab] 接在一串指令的第二个字以后时，则为『文件/文件名补齐』！
  > - 若安装bash-completion 软件，则在某些指令后面使用[tab] 按键时，可以进行『选项/参数的补齐』功能！

- 别名设定 alias

- 程序化脚步 shell scirpt

  > 就是把众多的命令放入一个文件中，批次处理，类似我们的程序一样，这样可以批量处理命令，提高效率

- 通配符 shell 脚本支持通配符
- 任务管理、前/后台

### 查询某个命令是否为内部命令 type

怎么知道这个指令是来自于外部指令(指的是其他非bash 所提供的指令) 或是内建在bash 当中的呢？

利用type 命令来达到目的。

![截屏2020-09-06 下午2.41.01](https://tva1.sinaimg.cn/large/007S8ZIlgy1gigxkcylprj30vw0aqmyw.jpg)

我们看到 利用 type + commadName 可以得到 xx is a shell builtin 的字样，说明这是内置的shell 命令；

```
[dmtsai@study ~]$ type [-tpa] name 
选项与参数：
    ：不加任何选项与参数时，type 会显示出name 是外部指令还是bash 内建指令
-t ：当加入-t 参数时，type 会将name 以底下这些字眼显示出他的意义：
      file ：表示为外部指令；
      alias ：表示该指令为命令别名所设定的名称；
      builtin ：表示该指令为bash 内建的指令功能；
-p ：如果后面接的name 为外部指令时，才会显示完整文件名；
-a ：会由PATH 变量定义的路径中，将所有含name 的指令都列出来，包含alias

范例一：查询一下ls这个指令是否为bash内建？
[dmtsai@study ~]$ type ls 
ls is aliased to `ls --color=auto' <==未加任何参数，列出ls的最主要使用情况 
[dmtsai@study ~]$ type -t ls 
alias                               < ==仅列出ls执行时的依据 
[dmtsai@study ~]$ type -a ls 
ls is aliased to `ls --color=auto' <==最先使用aliase 
ls is /usr/bin/ls                   <= =还有找到外部指令在/bin/ls
```

**注意：Mac 中的 -t 参数没有用。和linux 有些不一样；大部分的linux命令都可以在mac中找到，但有些细节不一样**

### Bash 指令执行

我们知道 Enter 是执行某个指令，当某个指令太长时，一行无法显示，需要换行输出，这时候Enter 就不能充当执行功能，而是换行。怎么弄呢？就是 `\Eneter` 就是反斜杠 + Enter，==中间不能有空格== 。

若你输入了一串错误的指令时，你想要快速的将这串指令整个删除掉，一般来说，我们都是按下删除键的。有没有其他的快速组合键可以协助呢？

| 组合键            | 功能与示范                                                   |
| ----------------- | ------------------------------------------------------------ |
| [ctrl]+u/[ctrl]+k | 分别是从游标处向前删除指令串([ctrl]+u) 及向后删除指令串([ctrl]+k)。 |
| [ctrl]+a/[ctrl]+e | 分别是让游标移动到整个指令串的最前面([ctrl]+a) 或最后面([ctrl]+e)。 |

## Shell 变量功能

我们熟知的PATH环境变量，这其中的“变量” 就是这样的例子。简单来说，我们先把一些常用的指令存储起来，用一个字符来代替，后面要用到这个变量时，实际是用之前设定的内容。这样的好处就是方便、灵活。

或者在编码时，我们设置一个通用的变量，然后后面都去使用这个变量，当要修改变量值时，直接修改设置变量的地方，不必修改每个使用的地方，这样使得我们程序变得健壮。这也是变量的意义。

**一般的 环境变量都以大写字符 来表示，具有全局性的含义**

所以给其下个定义：变量就是以一组文字或符号等，来取代一些设定或者是一串保留的资料！

### 变量的读取、设置

#### 变量读取echo

利用echo 这个指令来取用变量， 但是，变量在被取用时，前面必须要加上美元『 $ 』才行；

```
[dmtsai@study ~]$ echo $variable 
[dmtsai@study ~]$ echo $PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
[dmtsai@study ~]$ echo ${PATH}   #近年来，鸟哥比较偏向使用这种格式喔！
```

在自己的mac上演示：

```
shijianhua@sjh-MacPro document % echo PATH
PATH 应该加上$符号才行
shijianhua@sjh-MacPro document % echo $PATH
/Library/Frameworks/Python.framework/Versions/3.8/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
shijianhua@sjh-MacPro document % echo $HOME
/Users/shijianhua
shijianhua@sjh-MacPro document %
```

> bash 在你没有设定的变量中强迫去echo 时，它会显示出空的值。在其他某些shell 中，随便去echo 一个不存在的变量，它是会出现错误讯息的喔

#### 变量设定

**规则**

1. 变量与变量内容以一个等号『=』来连结，如下所示：
   `『myname=VBird』`
2. 等号两边不能直接接空白字符，如下所示为错误：
   `『myname = VBird』或『myname=VBird Tsai』`
3. ==变量名称只能是英文字符与数字，但是开头字符不能是数字==，如下为错误：`『2myname=VBird』`
4. 变量内容若有空白字符可使用双引号『"』或单引号『'』将变量内容结合起来，==注意单引号和双引号区别==
   - 双引号内的特殊字符如\$等，可以保有原本的特性，如下所示：
     『var="lang is ​\$LANG"』则『echo $var』可得『lang is zh_TW.UTF-8』；==这里的\$LANG 表示引用了系统变量LANG的含义，见第七条说明==
   - 单引号内的特殊字符则仅为一般字符(纯文字)，如下所示：
     『var='lang is \$LANG'』则『echo ​\$var』可得『lang is $LANG』
5. 可用反斜杠『 \ 』将特殊符号(如[Enter], $, \,空白字符, '等)变成一般字符，如：『myname=VBird\ Tsai』
6. 在一串指令的执行中，还需要藉由其他额外的指令所提供的资讯时，可以使用反单引号『`指令`』或『\$(指令)』。特别注意，那个`是键盘上方的数字键1左边那个按键，而不是单引号！例如想要取得核心版本的设定：
   『version=$(uname -r)』再『echo $version』可得『3.10.0-229.el7.x86_64』
7. 若该变量为扩增变量内容时，则可用"\$变量名称"或\${变量}累加内容，如下所示：
   `『PATH="​\$PATH":/home/bin』或『PATH=${PATH} :/home/bin』`
8. 若该变量需要在其他子程序执行，则需要以export来使变量变成环境变量：『export PATH』
9. 通常大写字符为系统预设变量，自行设定变量可以使用小写字符，方便判断==(这是一个约定习俗，好比 java 常量要用大写字符命令一样)== ；
10. 取消变量的方法为使用unset：『unset变量名称』例如取消myname的设定：`『unset myname』`

**使用案例**

```
范例一：设定一变量name ，且内容为VBird 
[dmtsai@study ~]$ 12name=VBird 
bash: 12name=VBird: command not found...   <==萤幕会显示错误！因为不能以数字开头！
[dmtsai@study ~]$ name = VBird             <==还是错误！因为有空白！
[dmtsai@study ~]$ name=VBird               <==OK的啦！

范例二：承上题，若变量内容为VBird's name呢，就是变量内容含有特殊符号时： 
[dmtsai@study ~]$ name=VBird's name   
# 单引号与双引号必须要成对，在上面的设定中仅有一个单引号，因此当你按下enter后，
# 你还可以继续输入变量内容。这与我们所需要的功能不同，失败啦！
#记得，失败后要复原请按下[ctrl]-c结束！
[dmtsai@study ~]$ name="VBird's name"     <==OK的啦！
#指令是由左边向右找→，先遇到的引号先有用，因此如上所示，单引号变成一般字符！
[dmtsai@study ~]$ name='VBird's name'     <==失败的啦！
#因为前两个单引号已成对，后面就多了一个不成对的单引号了！因此也就失败了！
[dmtsai@study ~]$ name=VBird\'s\ name      <==OK的啦！
#利用反斜线(\)跳脱特殊字符，例如单引号与空白键，这也是OK的啦！

范例三：我要在PATH这个变量当中『累加』:/home/dmtsai/bin这个目录 
[dmtsai@study ~]$ PATH=$PATH:/home/dmtsai/bin 
[dmtsai@study ~]$ PATH=" $PATH":/home/dmtsai/bin 
[dmtsai@study ~]$ PATH=${PATH}:/home/dmtsai/bin 
#上面这三种格式在PATH里头的设定都是OK的！但是底下的例子就不见得啰！

范例四：承范例三，我要将name的内容多出"yes"呢？
[dmtsai@study ~]$ name=$nameyes   
#知道了吧？如果没有双引号，那么变量成了啥？name的内容是$nameyes这个变量！
#呵呵！我们可没有设定过nameyes这个变量呐！所以，应该是底下这样才对！
[dmtsai@study ~]$ name="$name"yes 
[dmtsai@study ~]$ name=${name}yes   <==以此例较佳！

范例五：如何让我刚刚设定的name=VBird可以用在下个shell的程序？
[dmtsai@study ~]$ name=VBird 
[dmtsai@study ~]$ bash         <==进入到所谓的子程序 
[dmtsai@study ~]$ echo $name   <==子程序：再次的echo一下；
       <= =嘿嘿！并没有刚刚设定的内容喔！
[dmtsai@study ~]$ exit         <==子程序：离开这个子程序 
[dmtsai@study ~]$ export name 
[dmtsai@study ~]$ bash         <==进入到所谓的子程序 
[dmtsai@study ~] $ echo $name   <==子程序：在此执行！
VBird   <==看吧！出现设定值了！
[dmtsai@study ~]$ exit         <==子程序：离开这个子程序
```

再次对单引号、双引号做出例子说明：

**双引号仍然可以保有变量的内容，但单引号内仅能是一般字符，没有特殊含义**

```
[dmtsai@study ~]$ name=VBird
[dmtsai@study ~]$ echo $name
VBird
[dmtsai@study ~]$ myname="$name its me"
[dmtsai@study ~]$ echo $myname
VBird its me
[ dmtsai@study ~]$ myname='$name its me'
[dmtsai@study ~]$ echo $myname
$name its me
```

### 系统变量

用env (environment 缩写) 观察环境变量与常见环境变量说明 (自己的mac电脑)

```
bash-3.2$ env
TERM_PROGRAM=iTerm.app
SHELL=/bin/zsh
TERM=xterm-256color
TMPDIR=/var/folders/bg/99jkmcd53j7g54zv5hffb8d80000gn/T/
TERM_PROGRAM_VERSION=3.3.9
TERM_SESSION_ID=w1t0p0:0672E0E5-423A-4B50-80ED-1765F1B5CD15
USER=shijianhua
name=sjh
COMMAND_MODE=unix2003
SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.lhg18DnqOB/Listeners
__CF_USER_TEXT_ENCODING=0x0:25:52
PATH=/Library/Frameworks/Python.framework/Versions/3.8/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
LaunchInstanceID=67318B74-238E-4C3B-987C-D53B01E7F758
PWD=/Users/shijianhua
LANG=zh_CN.UTF-8
ITERM_PROFILE=Default
XPC_FLAGS=0x0
XPC_SERVICE_NAME=0
COLORFGBG=7;0
HOME=/Users/shijianhua
SHLVL=3
LC_TERMINAL_VERSION=3.3.9
ITERM_SESSION_ID=w1t0p0:0672E0E5-423A-4B50-80ED-1765F1B5CD15
LOGNAME=shijianhua
LC_TERMINAL=iTerm2
SECURITYSESSIONID=186a9
COLORTERM=truecolor
_=/usr/bin/env
```

这里面有系统的，也有我自己设定的name=sjh，然后我们对其中的几个变量做一下解读：

- **HOME**
  代表使用者的家目录。还记得我们可以使用cd ~去到自己的家目录吗？或者利用cd就可以直接回到使用者家目录了。那就是取用这个变量啦～有很多程序都可能会取用到这个变量的值！

- **SHELL**
  告知我们，目前这个环境使用的SHELL是哪支程序？Linux预设使用/bin/bash的啦！而mac的是bin/zsh

- **HISTSIZE**
  这个与『历史命令』有关，亦即是，我们曾经下达过的指令可以被系统记录下来，而记录的『笔数』则是由这个值来设定的。

- **PATH**
  就是执行档搜寻的路径啦～目录与目录中间以冒号(:)分隔，由于文件的搜寻是依序由PATH的变量内的目录来查询，所以，目录的顺序也是重要的喔。

- **LANG**

  显示系统编码语系 中文和字符集 utf-8；

### 自定义变量

除了env 还有set 也可以看到相关的设置，还包含自定义变量

```
shijianhua@sjh-MacPro ~ % clear
shijianhua@sjh-MacPro ~ % abc=123
shijianhua@sjh-MacPro ~ % a=e
shijianhua@sjh-MacPro ~ % set
'!'=0
'#'=0
'$'=33310
'*'=(  )
-=569XZilms
0=-zsh
'?'=0
@=(  )
ARGC=0
CDPATH=''
COLORFGBG='7;0'
COLORTERM=truecolor
ZSH_VERSION=5.7.1
_=set
__CF_USER_TEXT_ENCODING=0x0:25:52
a=e
abc=123
aliases
argv=(  )
```

这里看到了我们自己定义的a 和 abc 变量了。

- $：(关于本shell 的PID)

美元\$本身也是个变量喔！代表的是『目前这个Shell 的执行绪代号』，亦即是所谓的PID (Process ID)。获取shell 的PID ，就可以用：『 echo $$ 』即可！出现的数字就是你的PID 号码。

```
shijianhua@sjh-MacPro ~ % echo $$
33310
```

- ?：(关于上个执行指令的回传值)

问号也是一个特殊的变量？没错！在bash里面这个变量可重要的很！这个变量是：『上一个执行的指令所回传的值』，上面这句话的重点是『上一个指令』与『回传值』两个地方。当我们执行某些指令时，这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令，则会回传一个0值，如果执行过程发生错误，就会回传『错误代码』！一般就是以非为0的数值来取代。我们以底下的例子来看看：

```
shijianhua@sjh-MacPro ~ % sjs=abc
shijianhua@sjh-MacPro ~ % echo $?
0
shijianhua@sjh-MacPro ~ % 1sjhh=12
zsh: command not found: 1sjhh=12
shijianhua@sjh-MacPro ~ % echo $?
127
shijianhua@sjh-MacPro ~ %
```

### export 自定义变量转成环境变量

环境变量与自定义变量，那么这两者之间有啥差异呢？其实这两者的差异在于『 该变量是否会被子进程所继续引用』。那么啥是父进程？子进程？

当你登入Linux 并取得一个bash 之后，你的bash 就是一个独立的进程，这个程序的识别使用的是一个称为进程标识符，被称为PID 。接下来你在这个bash 底下所下达的任何命令都是由这个bash 所衍生出来的，那些被下达的指令就被称为子进程。

![image-20200906160854169](https://tva1.sinaimg.cn/large/007S8ZIlgy1gigzvld2vej31400u0e81.jpg)

如上所示，我们在原本的bash 底下执行另一个bash ，结果操作的环境介面会跑到第二个bash 去(就是子程序)， 那原本的bash 就会在暂停的情况(睡着了，就是sleep)。整个指令运作的环境是实线的部分！若要回到原本的bash 去， 就只有将第二个bash 结束掉(下达exit 或logout) 才行。

**变量和进程的关系**

子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量；

如何把自定义转成环境变量？

`export 变量名称`

**可以这样理解：环境变量相当于编程中的全局变量，自定义变量相当于私有变量，只能自己访问，通过export可以使之成为全局变量。**

### 获取键盘输入read

类似java编程语言的Read（System.in）来读取控制台用户的输入，这个read也是一样的功能。

```
dmtsai@study ~]$ read [-pt] variable 
选项与参数：
-p ：后面可以接提示字元！
-t ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者啦！

范例一：让使用者由键盘输入一内容，将该内容变成名为atest的变量 
[dmtsai@study ~]$ read atest 
This is a test         <==此时游标会等待你输入！请输入左侧文字看看 
[dmtsai@study ~]$ echo ${atest} 
This is a test           <==你刚刚输入的资料已经变成一个变量内容！

范例二：提示使用者30秒内输入自己的大名，将该输入字串作为名为named的变量内容 
[dmtsai@study ~]$ read -p "Please keyin your name: " -t 30 named 
Please keyin your name: VBird Tsai    <==注意看，会有提示字元喔！
[dmtsai@study ~]$ echo ${named} 
```

Mac 上这个命令，参数好像不管用 -p ，其表现形式也不一样。

### 声明变量

declare 是声明变量的语法；

```
[dmtsai@study ~]$ declare [-aixr] variable 
选项与参数：
-a ：将后面名为variable 的变量定义成为阵列(array) 类型
-i ：将后面名为variable 的变量定义成为整数数字(integer) 类型
-x ：用法与export 一样，就是将后面的variable 变成环境变量；
-r ：将变量设定成为readonly 类型，该变量不可被更改内容，也不能unset


shijianhua@sjh-MacPro ~ % declare -i test=1
shijianhua@sjh-MacPro ~ % echo $test
1
```

- 变量类型预设为『字符串』，所以若不指定变量类型，则1+2 为一个『字串』而不是『表达式』。
- bash 环境中的数值运算，预设最多仅能到达整数形态，所以1/3 结果是0；

创建数组

```
shijianhua@sjh-MacPro ~ % a[0]="sjh"
zsh: a: assignment to invalid subscript range
shijianhua@sjh-MacPro ~ % a[1]="sjh"
shijianhua@sjh-MacPro ~ % a[2]="sjh1"
shijianhua@sjh-MacPro ~ % echo $a[2]
sjh1
shijianhua@sjh-MacPro ~ %
```

注意：shell的数组不是从0开始的，从1开始的，这一点要注意。另外，直接声明即可。

## 别名alias

我们知道有些命令很长，或者不好记忆，前面提到的可以设置为环境变量；还可以进行取一个名字来替代，好比每个人有小名，区别于“学名” 我们称呼“小名”也是可以的，说白了就是方便记忆、使用而已，像是编程里面的“地址引用”罢了。

比如说：对于git 操作而言，有很多的参数，也比较复杂，这时候用别名是很有用的，像切换分支 git checkout -b branchName; 可以简化为 `git checkout -b `设置别名为 `git cb ` 这样就方便了一点；

当你不想使用别名后，可以通过 unalias 去取消；

```
alias rm='rm -i'
```

rm 表示移出文件，加了 -i 表示是否确定删除，防止误删文件；这样通过 alias 设置就可以 以后通过rm 替代 rm -i ，后面如果不想在使用这个别名了，那我们可以 `unalias rm` 取消。

**开始学习时，不建议使用别名，还是尽可能把每个命令打出来至熟悉透顶，后面在考虑别名**  

## 历史命令history

当我们开机后，我们打开终端，按向上箭头，会显示上一次显示的命令，这个是怎么做到的呢？

我们知道历史命令存在 ~/.bash_history；历史命令的读取与记录是这样的：

- 当我们以bash 登入Linux 主机之后，系统会主动的由家目录的~/.bash_history 读取以前曾经下过的指令，那么~/.bash_history 会记录几笔资料呢？这就与你bash 的 HISTFILESIZE 这个变数设定值有关了！
- 假设我这次登入主机后，共下达过100次指令，『等我登出时，系统就会将10 \~1100这总共1000笔历史命令更新到 ~/.bash_history当中。』也就是说，历史命令在我登出时，会将最近的HISTFILESIZE笔记录到我的纪录档当中啦！
- 当然，也可以用history -w 强制立刻写入的！那为何用『更新』两个字呢？因为~/.bash_history 记录的笔数永远都是HISTFILESIZE 那么多，旧的讯息会被主动的拿掉！仅保留最新的！

我们可以借助 history 命令来做一些有趣的事情。

```
[dmtsai@study ~]$ history [n] 
[dmtsai@study ~]$ history [-c] 
[dmtsai@study ~]$ history [-raw] histfiles 
选项与参数：
n ：数字，意思是『要列出最近的n 笔命令列表』的意思！
-c ：将目前的shell 中的所有history 内容全部消除
-a ：将目前新增的history 指令新增入histfiles 中，若没有加histfiles ，
      则预设写入~/.bash_history
-r ：将histfiles 的内容读到目前这个shell 的history 记忆中；
-w ：将目前的history 记忆内容写入histfiles 中！

范例一：列出目前记忆体内的所有history记忆 
[dmtsai@study ~]$ history 
#前面省略
 1017 man bash
 1018 ll
 1019 history 
 1020 history
# 列出的资讯当中，共分两栏，第一栏为该指令在这个shell 当中的代码，
# 另一个则是指令本身的内容喔！至于会秀出几笔指令记录，则与HISTSIZE 有关！

范例二：列出目前最近的3笔资料 
[dmtsai@study ~]$ history 3
 1019 history 
 1020 history
 1021 history 3

范例三：立刻将目前的资料写入histfile当中 
[dmtsai@study ~]$ history -w 
#在预设的情况下，会将历史纪录写入~/.bash_history当中！
[dmtsai@study ~]$ echo ${HISTSIZE}
1000
```

还有下面这些：

```
[dmtsai@study ~]$ !number  [dmtsai@study ~]$ !command  [dmtsai@study ~]$ !!  选项与参数： number ：执行第几笔指令的意思； command ：由最近的指令向前搜寻『指令串开头为command』的那个指令，并执行； !! ：就是执行上一个指令(相当于按↑按键后，按Enter)
```

## Bash shell 操作环境

bash 也是一个应用程序，当我们进入了这个程序后，我们可以获取很多变量，然后退出这个程序，这些变量就没有了，为什么呢？这些变量从哪来的呢？

其实回答这个问题就是标题 ：bash 运行的环境问题，就是运行bash时，系统会加载一些配置文件（配置文件记录了很多值）给这个程序用，然后通过这个程序读取这些值。这些配置文件又可以分为全局以及使用者个人偏好设置。要注意的是， 我们前几个小节谈到的命令别名、自订的变数，在你登出bash 后就会失效，所以你想要保留你的设定， 就得要将这些设定写入设定档才行现在我们来了解一下有哪些相关的配置？

### 命令查找顺序

假如说，我们系统内有好几个同名的命令，比如有bash 内建的，alias 别名的，还有path 配置的，到底哪个应该先执行呢？这个问题想过没？

1. 以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；
2. 由alias 找到该指令来执行；
3. 由bash 内建的(builtin) 指令来执行；
4. 透过$PATH 这个变数的顺序搜寻到的第一个指令来执行。

### 环境设置

#### Login 与non-login

- login shell：取得bash 时需要完整的登入流程的，就称为login shell。举例来说，你要由tty1 ~ tty6 登入，需要输入使用者的帐号与密码，此时取得的bash 就称为『 login shell 』啰；

  

- non-login shell：取得bash 介面的方法不需要重复登入的举动，举例来说，(1)你以X window 登入Linux 后， 再以X 的图形化介面启动终端机，此时那个终端介面并没有需要再次的输入帐号与密码，那个bash 的环境就称为non-login shell了。(2)你在原本的bash 环境下再次下达bash 这个指令，同样的也没有输入帐号密码， 那第二个bash (子程序) 也是non-login shell 。

为什么要介绍login, non-login shell 呢？这两个 bash 读取的设定档资料是不一样的。由于我们需要登入系统，所以先谈谈login shell 会读取哪些设定档？一般来说，login shell 其实只会读取这两个设定档：

1. /etc/profile：这是系统整体的设定，你最好不要修改这个文件；
2. ~/.bash_profile 或~/.bash_login 或~/.profile：属于使用者个人设定，你要改自己的资料，就写入这里！

---

#### /etc/profile （login shell 会读）

`vi /etc/profile` 进入这个文本

```
if [ -x /usr/libexec/path_helper ]; then
        eval `/usr/libexec/path_helper -s`
fi

if [ "${BASH-no}" != "no" ]; then
        [ -r /etc/bashrc ] && . /etc/bashrc
fi
```

上面是mac 显示的内容。至于其含义，先暂时不管了，后面在探讨。刚刚说了有三个文档和个人偏好设置有关。如下：

1. ~/.bash_profile
2. ~/.bash_login
3. ~/.profile

其实bash的login shell设定只会读取上面三个文件的其中一个，而读取的顺序则是依照上面的顺序。

### 终端环境设置

​		在tty1 ~ tty6这六个文字介面的终端机(terminal)环境中登入，登入的时候我们可以取得一些字元设定的功能喔！举例来说，我们可以利用倒退键(backspace，就是那个←符号的按键)来删除命令列上的字元，也可以使用[ctrl]+c来强制终止一个指令的运行，当输入错误时，就会有声音跑出来警告。这是怎么办到的呢？很简单啊！因为登入终端机的时候，会自动的取得一些终端机的输入环境的设定啊！

那么如何查阅目前的一些按键内容呢？可以利用stty (setting tty 终端机的意思) 呢！

```
[dmtsai@study ~]$ stty [-a] 
选项与参数：
-a ：将目前所有的stty 参数列出来；

范例一：列出所有的按键与按键内容 
[dmtsai@study ~]$ stty -a
speed 38400 baud; rows 20; columns 90; line = 0;
intr = ^C ; quit = ^\; erase = ^? ; kill = ^U; eof = ^D ; eol = <undef>; eol2 = <undef>;
swtch = <undef>; start = ^Q ; stop = ^S ; susp = ^Z ; rprnt = ^R; werase = ^W; lnext = ^V;
flush = ^O; min = 1; time = 0;
....(以下省略)....
```

stty -a来列出目前环境中所有的按键列表，在上头的列表当中，需要注意的是特殊字体那几个，此外，如果出现^表示[Ctrl]那个按键的意思。举例来说， intr = ^C表示利用[ctrl] + c来达成的。几个重要的代表意义是：

- intr : 送出一个interrupt (中断) 的讯号给目前正在run 的程序(就是终止啰！)；
- quit : 送出一个quit 的讯号给目前正在run 的程序；
- erase : 向后删除字元，
- kill : 删除在目前指令列上的所有文字；
- eof : End of file 的意思，代表『结束输入』。
- start : 在某个程序停止后，重新启动他的output
- stop : 停止目前萤幕的输出；
- susp : 送出一个terminal stop 的讯号给正在run 的程序。

除了stty 之外，其实我们的bash 还有自己的一些终端机设定值呢！那就是利用set 来设定的！我们之前提到一些变数时，可以利用set 来显示，除此之外，其实set 还可以帮我们设定整个指令输出/输入的环境。

```
dmtsai@study ~]$ set [-uvCHhmBx] 
选项与参数：
-u ：预设不启用。若启用后，当使用未设定变数时，会显示错误讯息；
-v ：预设不启用。若启用后，在讯息被输出前，会先显示讯息的原始内容；
-x ：预设不启用。若启用后，在指令被执行前，会显示指令内容(前面有++ 符号)
-h ：预设启用。与历史命令有关；
-H ：预设启用。与历史命令有关；
-m ：预设启用。与工作管理有关；
-B ：预设启用。与刮号[] 的作用有关；
-C ：预设不启用。若使用> 等，则若文件存在时，该文件不会被覆盖。

范例一：显示目前所有的set设定值 
[dmtsai@study ~]$ echo $-
himBH
# 那个$- 变数内容就是set 的所有设定啦！bash 预设是himBH 喔！

范例二：设定"若使用未定义变数时，则显示错误讯息" 
[dmtsai@study ~]$ set -u 
[dmtsai@study ~]$ echo $vbirding
-bash: vbirding: unbound variable
# 预设情况下，未设定/未宣告的变数都会是『空的』，不过，若设定-u 参数，
# 那么当使用未设定的变数时，就会有问题啦！很多的shell 都预设启用-u 参数。
# 若要取消这个参数，输入set +u 即可！

范例三：执行前，显示该指令内容。
[dmtsai@study ~]$ set -x 
++ printf '\033]0;%s@%s:%s\007' dmtsai study '~'     #这个是在列出提示字元的控制码！
[dmtsai@study ~]$ echo ${HOME}
+ echo /home/dmtsai
/home/dmtsai
++ printf '\033]0;%s@%s:%s\007' dmtsai study '~'
# 看见否？要输出的指令都会先被列印到萤幕上喔！前面会多出+ 的符号！
```

bash 预设的组合键给他汇整如下：

| 组合按键 | 执行结果                            |
| -------- | ----------------------------------- |
| Ctrl + C | 终止目前的命令                      |
| Ctrl + D | 输入结束(EOF)，例如邮件结束的时候； |
| Ctrl + M | 就是Enter 啦！                      |
| Ctrl + S | 暂停萤幕的输出                      |
| Ctrl + Q | 恢复萤幕的输出                      |
| Ctrl + U | 在提示字元下，将整列命令删除        |
| Ctrl + Z | 『暂停』目前的命令                  |

## 通配符和特殊符号

#### 通配符

| 符号  | 意义                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 代表『 0 个到无穷多个』任意字元                              |
| ?     | 代表『一定有一个』任意字元                                   |
| [ ]   | 同样代表『一定有一个在括号内』的字元(非任意字元)。例如[abcd] 代表『一定有一个字元， 可能是a, b, c, d 这四个任何一个』 |
| [ - ] | 若有减号在中括号内时，代表『在编码顺序内的所有字元』。例如[0-9] 代表 0 到9 之间的所有数字，因为数字的语系编码是连续的！ |
| [^ ]  | 若中括号内的第一个字元为指数符号(^) ，那表示『反向选择』，例如[^abc] 代表一定有一个字元，只要是非a, b, c 的其他字元就接受的意思。 |

#### 特殊符号

| 符号  | 内容                                                         |
| ----- | ------------------------------------------------------------ |
| #     | 注解符号：这个最常被使用在script 当中，视为说明！在后的资料均不执行 |
| \     | 跳脱符号：将『特殊字元或万用字元』还原成一般字元             |
| \|    | 管线(pipe)：分隔两个管线命令的界定(后两节介绍)；             |
| ;     | 连续指令下达分隔符号：连续性命令的界定(注意！与管线命令并不相同) |
| ~     | 使用者的家目录                                               |
| $     | 取用变数前置字元：亦即是变数之前需要加的变数取代值           |
| &     | 工作控制(job control)：将指令变成背景下工作                  |
| !     | 逻辑运算意义上的『非』 not 的意思！                          |
| /     | 目录符号：路径分隔的符号                                     |
| >, >> | 资料流重导向：输出导向，分别是『取代』与『累加』             |
| <, << | 资料流重导向：输入导向(这两个留待下节介绍)                   |
| ' '   | 单引号，不具有变数置换的功能($ 变为纯文字)                   |
| " "   | 具有变数置换的功能！($ 可保留相关功能)                       |
| \`\`  | 两个『 ` 』中间为可以先执行的指令，亦可使用$( )              |
| ( )   | 在中间为子shell 的起始与结束                                 |
| { }   | 在中间为命令区块的组合！                                     |



## 数据流重定向

数据流重导向(redirect) 由字面上的意思来看，好像就是将『数据给他传导到其他地方去』的样子？没错～数据流重导向就是将某个指令执行后应该要出现在萤幕上的数据， 给他传输到其他的地方，例如文件或者是设备(例如打印机之类的)；这个东西很有用，比如说我们在logcat时，我们想要把这些显示屏幕上的log保存到file，并上传到服务器。这个场景就说明了数据流重定向到应用；

### 数据流重定向

![image-20200908204713808](https://tva1.sinaimg.cn/large/007S8ZIlgy1gijj5sb9wfj31400u01kx.jpg)

执行某个命令（从文件中读取数据）后，并显示到屏幕。上图中，standard output 与standard error output 分别代表『标准输出(STDOUT)』与『标准错误输出(STDERR)』， 这两个玩意儿预设都是输出到萤幕上面来的啊！那么什么是标准输出与标准错误输出呢？

**标准输出指的是『指令执行所回传的正确的信息』，而标准错误输出可理解为『指令执行失败后，所回传的错误信息』**

举例：系统预设有/etc/crontab但却无/etc/vbirdsay，此时若下达『 cat /etc/crontab /etc/vbirdsay 』这个指令时，cat会进行：

- 标准输出：读取/etc/crontab 后，将该文件内容显示到萤幕上；
- 标准错误输出：因为无法找到/etc/vbirdsay，因此在萤幕上显示错误讯息

这时，错误的、正确的命令都显示到了屏幕上，很混乱，我们想只显示正确的信息，怎么办呢？这时候就用到了数据流重定向。可以将standard output (简称stdout) 与standard error output (简称stderr) 分别传送到其他的文件或设备去，他们对应的特殊字符如下：

1. 标准输入(stdin) ：代码为0 ，使用< 或<< ；
2. 标准输出(stdout)：代码为1 ，使用> 或>> ；
3. 标准错误输出(stderr)：代码为2 ，使用2> 或2>> ；

另外，说明：

- 1> ：以覆盖的方法将『正确的资料』输出到指定的文件或设备上；
- 1>>：以追加的方法将『正确的资料』输出到指定的文件或设备上；
- 2> ：以覆盖的方法将『错误的资料』输出到指定的文件或设备上；
- 2>>：以追加的方法将『错误的资料』输出到指定的文件或设备上；

> 数字1或2 和 符号之间没有空格

**Standard output > 或 >>**

应用：比如说我运行一个命令，把正确的信息存放file1中，错误的信息存到file2中？

`find /Users/shijianhua/Documents > file1 2> file2` 执行这样的命令即可。如果想追加则用 >> 替代。另外，如果想把两个信息都放到 同一个文件中，该怎么办呢？

```
范例五：将指令的资料全部写入名为list的文件中 
[dmtsai@study ~]$ find /home -name .bashrc > list 2> list   <==错误 
[dmtsai@study ~]$ find /home - name .bashrc > list 2>&1      <==正确 
[dmtsai@study ~]$ find /home -name .bashrc &> list          <==正确
```

第一行错误的原因是，由于两股数据同时写入一个文件，又没有使用特殊的语法，此时两股资料可能会交叉写入该文件内，造成次序的错乱。。至于写入同一个文件的特殊语法如上表所示，你可以使用2>&1也可以使用 &> ，一般来说，鸟哥比较习惯使用2>&1的语法啦！

**Standard input < 或 <<**

将原本需要由键盘输入的数据，改由文件内容来取代。

```
范例六：利用cat指令来建立一个文件的简单流程 
[dmtsai@study ~]$ cat > catfile 
testing
cat file test 
<==这里按下[ctrl]+d来离开

[dmtsai@study ~]$ cat catfile
testing
cat file test
```

由于加入>在cat后，所以那个catfile会被主动的建立，而内容就是刚刚键盘上面输入的那两行资料了。在看下面：

```
[dmtsai@study ~]$ cat > catfile << "eof" 
> This is a test. 
> OK now stop 
> eof   <==输入这关键字，立刻就结束而不需要输入[ctrl]+d

[dmtsai@study ~]$ cat catfile
This is a test.
OK now stop      <==只有这两行，不会存在关键字那一行！
```

这里，不需要执行 ctrl + d ，通过eof 字符来实现，去除了键盘操纵，更加方便脚步的执行。

那我能不能用纯文字档取代键盘的输入，也就是说，用某个文件的内容来取代键盘的敲击呢？ 可以的！

```
范例七：用stdin取代键盘的输入以建立新文件的简单流程 
[dmtsai@study ~]$ cat > catfile < ~/.bashrc 
[dmtsai@study ~]$ ll catfile ~/.bashrc 
-rw-r-- r--. 1 dmtsai dmtsai 231 Mar 6 06:06 /home/dmtsai/.bashrc
-rw-rw-r--. 1 dmtsai dmtsai 231 Jul 9 18:58 catfile
 #注意看，这两个文件的大小会一模一样！几乎像是使用cp来复制一般！
```

> 我在mac 上测试 cat > sjhtest.txt < copy_temp.txt  没有成功，文档内容没有变化；

### 命令的执行判定

某些情况下，**很多指令我想要一次输入去执行，而不想要分次执行时**，该如何是好？基本上你有两个选择，一个是通过后面的[shell script](http://linux.vbird.org/linux_basic/0340bashshell-scripts.php) 撰写脚本去执行，一种则是通过下面的介绍来一次输入多重指令！

- 连续执行不相关指令 cmd; cmd

  执行多个指令，用分号隔开即可；**(注意：是不相关的指令，因为避免指令的结果有依赖性)**

  ```
  shijianhua@sjh-MacPro Documents % ls ; cat /Users/shijianhua/Documents/sjhtest.txt
  AndroidStudio		copy_temp.txt		office
  MacOS			gitLearn		resume
  OS			iOS			sjh
  androidProject		javaProject		sjhtest.txt
  androidtools		keystore		vpn
  cocos			md document		weixinminProgram
  sjhd
  sdlaksdfslfks ceshi测试尾巴
  ```

- && 或|| 结合 $? (指令回传值) 

  && 和 || 类似逻辑 “且” 与 “或” ，其规则是

  | 指令下达情况   | 说明                                                         |
  | -------------- | ------------------------------------------------------------ |
  | cmd1 && cmd2   | 1.若cmd1执行完毕且正确执行(\$?=0)，则开始执行cmd2。 <br />2.若cmd1执行完毕且为错误($?≠0)，则cmd2不执行。 |
  | cmd1 \|\| cmd2 | 1.若cmd1执行完毕且正确执行(\$?=0)，则cmd2不执行。<br /> 2.若cmd1执行完毕且为错误($?≠0)，则开始执行cmd2。 |

  我们知道指令有回传值表示正确与否，0 、1、 2；而“$” 就可以获取上一次指令的执行值；当两个执行时，我们要判断前一个命令其执行的对与否。 因为他会影响到后面指令的执行。

  

## 管道pipe

如果我们想要对某个命令执行的结果数据进行处理，前面说的可以用 数据流重定向 1> 、2> 等方式，假如说我想 对数据进行一些处理呢？比如说过滤一些字符，这时候前面说的 1> 、2>就不太能满足需要了。这时候可以用**pipe** 来实现。

比如说：在adb 工具获取logcat日志，我们想要获取exception 相关数据，可以这样 `adb logcat -v time | grep 'exception'`这样就能把exception 数据拿到手，避免了其他无用数据。这里的 ｜ 表示管道，然后经过 grep 命令再次处理。

相关的管道数据流示意图为： 

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1giknuf0nijj30cn02wdfo.jpg)

注意点：

- 管线命令仅会处理standard output，对于standard error output 会予以忽略
- 管线命令必须要能够接受来自前一个指令的资料成为standard input 继续处理才行。

想想为啥管道命令 有上面的两个特点？

### 截取 cut 、grep 

**CUT**

cut 表示 “切”，并且以“行”为单位。

```
[dmtsai@study ~]$ cut -d'分隔字元' -f fields  <==用于有特定分隔字元 
[dmtsai@study ~]$ cut -c字元区间             <==用于排列整齐的讯息
选项与参数：
-d ：后面接分隔字元。与-f 一起使用；
-f ：依据-d 的分隔字元将一段讯息分割成为数段，用-f 取出第几段的意思；
-c ：以字元(characters) 的单位取出固定字元区间；

范例一：将PATH变数取出，我要找出第五个路径。
[dmtsai@study ~]$ echo ${PATH}
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
# 1 | 2 | 3 | 4 | 5 | 6 |

[dmtsai@study ~]$ echo ${PATH} | cut -d ':' -f 5 
#如同上面的数字显示，我们是以『 : 』作为分隔，因此会出现/home/dmtsai/.local/bin
#那么如果想要列出第3与第5呢？，就是这样： 
[dmtsai@study ~]$ echo ${PATH} | cut -d ':' -f 3,5

范例二：将export输出的讯息，取得第12字元以后的所有字串 
[dmtsai@study ~]$ export
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
.....(其他省略).....
# 注意看，每个资料都是排列整齐的输出！如果我们不想要『 declare -x 』时，就得这么做：

[dmtsai@study ~]$ export | cut -c 12-
HISTCONTROL="ignoredups"
HISTSIZE="1000"
HOME="/home/dmtsai"
HOSTNAME="study.centos.vbird"
.....(其他省略).....
# 知道怎么回事了吧？用-c 可以处理比较具有格式的输出资料！
# 我们还可以指定某个范围的值，例如第12-20 的字元，就是cut -c 12-20 等等！
```

**grep**

Grep 也是分析“行” 信息的，若当中有包含我们的字符，就将该行拿出来。

```
[dmtsai@study ~]$ grep [-acinv] [--color=auto] '搜寻字串' filename 
选项与参数：
-a ：将binary 文件以text 文件的方式搜寻资料
-c ：计算找到'搜寻字串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有'搜寻字串' 内容的那一行！
--color=auto ：可以将找到的关键字部分加上颜色的显示喔！

范例一：将last当中，有出现root的那一行就取出来； 
[dmtsai@study ~]$ last | grep 'root'

范例二：与范例一相反，只要没有root的就取出！
[dmtsai@study ~]$ last | grep -v 'root'

范例三：在last的输出讯息中，只要有root就取出，并且仅取第一栏 
[dmtsai@study ~]$ last | grep 'root' |cut -d ' ' -f1 
#在取出root之后，利用上个指令cut的处理，就能够仅取得第一栏啰！
```

### 排序 sort 、wc、uniq

**sort**

可以依据不同的数据类型态来排序，**排序的字符与语言的编码有关，**因此， 如果您需要排序时，建议使用LANG=C 来让语言统一，排序比较好一些；

```
[dmtsai@study ~]$ sort [-fbMnrtuk] [file or stdin] 
选项与参数：
-f ：忽略大小写的差异，例如A 与a 视为编码相同；
-b ：忽略最前面的空白字元部分；
-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法；
-n ：使用『纯数字』进行排序(预设是以文字型态来排序的)；
-r ：反向排序；
-u ：就是uniq ，相同的资料中，仅出现一行代表；
-t ：分隔符号，预设是用[tab] 键来分隔；
-k ：以那个区间(field) 来进行排序的意思

范例一：个人帐号都记录在/etc/passwd下，请将帐号进行排序。
[dmtsai@study ~]$ cat /etc/passwd | sort 
ab rt:x:173:173::/etc/abrt:/sbin/nologin
 ad m:x:3:4:adm:/var/adm:/ sbin/nologin
 al ex:x:1001:1002::/home/alex:/bin/bash
 #鸟哥省略很多的输出～由上面的资料看起来， sort是预设『以第一个』资料来排序，
# 而且预设是以『文字』型态来排序的喔！所以由a 开始排到最后啰！

范例二：/etc/passwd内容是以:来分隔的，我想以第三栏含后面资料来排序，该如何？
[dmtsai@study ~]$ cat /etc/passwd | sort -t ':' -k 3 
root:x: 0:0:root:/root:/bin/bash 
dmtsai:x: 1000:1000:dmtsai:/ home/dmtsai:/bin/bash 
alex:x: 1001:1002::/home/alex:/bin/bash 
arod:x: 1002:1003::/home/arod:/bin/bash 
#看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～若单纯以第三栏位来处理则是：

范例三：利用last ，将输出的资料仅取帐号，并加以排序 
[dmtsai@study ~]$ last | cut -d ' ' -f1 | sort
```

利用这个sort 再结合其他的，可以很方便的处理一些杂乱无章的文档。 比如结合 cut 、grep等，抓取部分信息在建立一个新文档。

**uniq**

如果我排序完成了，想要将重复的资料仅列出一个显示，可以怎么做呢？

```
[dmtsai@study ~]$ uniq [-ic] 
选项与参数：
-i ：忽略大小写字元的不同；
-c ：进行计数
```

**we**

统计某个文档有多少行、列、字符？

```
[dmtsai@study ~]$ wc [-lwm] 
选项与参数：
-l ：仅列出行；
-w ：仅列出多少字(英文单字)；
-m ：多少字元；

范例一：那个/etc/man_db.conf里面到底有多少相关字、行、字元数？
[dmtsai@study ~]$ cat /etc/man_db.conf | wc
    131 723 5171
# 输出的三个数字中，分别代表： 『行、字数、字元数』

范例二：我知道使用last 可以输出登入者，但是last 最后两行并非帐号内容，那么请问，
        我该如何以一行指令串取得登入系统的总人次？
[dmtsai@study ~]$ last | grep [a-zA-Z] | grep -v 'wtmp' | grep -v 'reboot' | \ 
> grep -v 'unknown' |wc -l 
#由于last会输出空白行, wtmp, unknown, reboot等无关帐号登入的资讯，因此，我利用
# grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰！
```

### 双向导向 tee

我们知道 `>` 会将资料流整个传送给文件或装置，因此我们除非去读取该文件或装置， 否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段讯息存下来，应该怎么做？

> 其实，这个很好理解，比如java 中的输出流就只能read 一次，后面就读取不到了，都是一个道理，不过应该都是linux 这边衍生过来的。这一点linux 和 java是一致的，但是和c 不一样。

![pic](http://linux.vbird.org/linux_basic/0320bash//0320bash_5.png)

tee 会同时将资料流分送到文件去与萤幕(screen)；而输出到萤幕的，其实就是stdout ，那就可以让下个指令继续处理喔！

```
[dmtsai@study ~]$ tee [-a] file 
选项与参数：
-a ：以累加(append) 的方式，将资料加入file 当中！

[dmtsai@study ~]$ last | tee last.list | cut -d " " -f1 
#这个范例可以让我们将last的输出存一份到last.list文件中；

[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more 
#这个范例则是将ls的资料存一份到~/homefile ，同时萤幕也有输出讯息！

[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more 
#要注意！tee后接的文件会被覆盖，若加上-a这个选项则能将讯息累加。
```

### 替换 tr、col 等等

**tr** 

tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！

```
[dmtsai@study ~]$ tr [-ds] SET1 ... 
选项与参数：
-d ：删除讯息当中的SET1 这个字串；
-s ：取代掉重复的字元！

范例一：将last输出的讯息中，所有的小写变成大写字元： 
[dmtsai@study ~]$ last | tr '[az]' '[AZ]' 
#事实上，没有加上单引号也是可以执行的，如：『 last | tr [az] [AZ] 』

范例二：将/etc/passwd输出的讯息中，将冒号(:)删除 
[dmtsai@study ~]$ cat /etc/passwd | tr -d ':'
```

**join**

把两个文件的相同行且

**paste**

把两个文件的相同行数的内容拼接到一起，中间以[tab]键隔开。注意：只会合并相同行。

```
[dmtsai@study ~]$ paste [-d] file1 file2 
选项与参数：
-d ：后面可以接分隔字元。预设是以[tab] 来分隔的！
- ：如果file 部分写成- ，表示来自standard input 的资料的意思。

范例一：用root身份，将/etc/passwd与/etc/shadow同一行贴在一起 
[root@study ~]# paste /etc/passwd /etc/shadow 
root : x : 0:0 : root:/root :/bin/bash root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin bin:*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:16372:0:99999:7:::
# 注意喔！同一行中间是以[tab] 按键隔开的！

范例二：先将/etc/group读出(用cat)，然后与范例一贴上一起！且仅取出前三行 
[root@study ~]# cat /etc/group|paste /etc/passwd /etc/shadow -|head -n 3 
#这个例子的重点在那个-的使用！那玩意儿常常代表stdin喔！

```



# 正则表达式

## 什么是正则表达式？

简单的说，正则表达式就是处理字串的方法，他是以行为单位来进行字串的处理行为， 正则表达式透过一些特殊符号的辅助，可以让使用者轻易的达到『搜寻/删除/取代』某特定字串的处理程序！**他是一个标准，字符串处理标准**；所以说在很多的平台都有正则表达式的运用，我们了解了这些标准，就可以在各个平台地方使用了。比如：java、python、javaScript 都是支持正则表达式。

一般的，正则表达式有基础版本的，也有扩展版本的。

## 基础正则表达式

### 语系对正则表达式影响

由于不同语系的编码资料并不相同，所以就会造成资料截取结果的差异了。举例来说，在英文大小写的编码顺序中，zh_TW.big5及C这两种语系的输出结果分别如下：

- LANG=C 时：0 1 2 3 4 ... ABCD ... Z abcd ...z
- LANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z

记录一些常用和重要的字符含义：

| 特殊符号      | 代表意义                                                   |
| ------------- | ---------------------------------------------------------- |
| **[:alnum:]** | 代表英文大小写字元及数字，亦即0-9, AZ, az                  |
| **[:alpha:]** | 代表任何英文大小写字元，亦即AZ, az                         |
| [:blank:]     | 代表空白键与[Tab] 按键两者                                 |
| [:cntrl:]     | 代表键盘上面的控制按键，亦即包括CR, LF, Tab, Del.. 等等    |
| **[:digit:]** | 代表数字而已，亦即0-9                                      |
| [:graph:]     | 除了空白字元(空白键与[Tab] 按键) 外的其他所有按键          |
| **[:lower:]** | 代表小写字符，亦即az                                       |
| [:print:]     | 代表任何可以被列印出来的字元                               |
| [:punct:]     | 代表标点符号(punctuation symbol)，亦即：" ' ? ! ; : # $... |
| **[:upper:]** | 代表大写字元，亦即AZ                                       |
| [:space:]     | 任何会产生空白的字元，包括空白键, [Tab], CR 等等           |
| [:xdigit:]    | 代表16 进位的数字类型，因此包括： 0-9, AF, af 的数字与字元 |

尤其上表中的[:alnum:], [:alpha:], [:upper:], [:lower:], [:digit:] 这几个一定要知道其含义。那他们有什么用呢？前面我们说了不同的语系设置可能导致字符的表现不同，这时候可以通过这些定义去消除这些差别，比如说 [:lower] 表示小写字母。

###  正则表达式语法

**常规类语法**

| RE 字 符  | 意义与范例                                                   |
| --------- | ------------------------------------------------------------ |
| ^word     | 意义：**待搜寻的字串(word)在行首**！ 范例：搜寻行首为#开始的那一行，并列出行号grep -n '^#' regular_express.txt |
| word$     | 意义：**待搜寻的字串(word)在行尾**！ 范例：将行尾为!的那一行列印出来，并列出行号grep -n '!$' regular_express.txt |
| .         | 意义：**代表『一定有一个任意字符』**！ 范例：搜寻的字串可以是(eve) (eae) (eee) (ee)，但不能仅有(ee) ！亦即e与e中间『一定』仅有一个字元，而空白字元也是字元！grep -n 'ee' regular_express.txt |
| \         | 意义：**shell的转义字符**，将特殊符号的特殊意义去除！ 范例：搜寻含有单引号'的那一行！grep -n  \\' regular_express.txt |
| *         | 意义：**重复零个到无穷多个的前一个RE字符** 范例：找出含有(es) (ess) (esss)等等的字串，注意，因为*可以是0个，所以es也是符合带搜寻字串。另外，因为*为重复『前一个RE字符』的符号，因此，在*之前必须要紧接着一个RE字符喔！例如任意字元则为『.*』 ！grep -n 'ess*' regular_express.txt |
| [list]    | 意义：**字元集合的RE字符，里面列出想要选取的字元（不过一个【】只能表示有一个字符）**！ 范例：搜寻含有(gl)或(gd)的那一行，需要特别留意的是，在[]当中『谨代表一个待搜寻的字元』，例如『 a[afl]y 』代表搜寻的字串可以是aay, afy, aly即[afl]代表a或f或l的意思！grep -n 'g[ld]' regular_express.txt |
| [n1-  n2] | 意义：**字元集合的RE字符，里面列出想要选取的字元范围**！ 范例：搜寻含有任意数字的那一行！需特别留意，在字元集合[]中的减号-是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确(在bash当中，需要确定LANG与LANGUAGE的变数是否正确！)例如所有大写字元则为[AZ]grep -n '[AZ]' regular_express.txt |
| [^list]   | 意义：**字元集合的RE字符，里面列出不要的字串或范围**！ 范例：搜寻的字串可以是(oog) (ood)但不能是(oot) ，那个\^在[]内时，代表的意义是『反向选择』的意思。例如，我不要大写字元，则为[\^AZ]。但是，需要特别注意的是，如果以grep -n [\^AZ] regular_express.txt来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个[\^AZ]是『非大写字元』的意思，因为每一行均有非大写字元，例如第一行的"Open Source"就有p,e,n,o....等等的小写字grep -n 'oo[\^t]' regular_express.txt |
| \{n,m\}   | 意义：**连续n到m个的『前一个RE字符』** 意义：若为\{n\}则是连续n个的前一个RE字符， 意义：若是\{n,\}则是连续n个以上的前一个RE字符！ 范例：在g与g之间有2个到3个的o存在的字串，亦即(goog)(gooog)grep -n 'go\{2,3\}g' regular_express.txt |

**扩展正则表达式**

| RE 字符 | 意义与范例                                                   |
| ------- | ------------------------------------------------------------ |
| +       | 意义：重复『一个或一个以上』的前一个RE字符 范例：搜寻(god) (good) (goood)...等等的字串。那个o+代表『一个以上的o 』所以，底下的执行成果会将第1, 9, 13行列出来。egrep -n 'go+d' regular_express.txt |
| ?       | 意义：『零个或一个』的前一个RE字符 范例：搜寻(gd) (god)这两个字串。那个o?代表『空的或1个o 』所以，上面的执行成果会将第13, 14行列出来。有没有发现到，这两个案例( 'go+d'与'go?d' )的结果集合与'go*d'相同？想想看，这是为什么喔！^_^egrep -n 'go?d' regular_express.txt |
| \|      | 意义：用或( or )的方式找出数个字串 范例：搜寻gd或good这两个字串，注意，是『或』！所以，第1,9,14这三行都可以被列印出来喔！那如果还想要找出dog呢？egrep -n 'gd\|good' regular_express.txt egrep -n 'gd\|good\|dog' regular_express.txt |
| ()      | 意义：找出『群组』字串 范例：搜寻(glad)或(good)这两个字串，因为g与d是重复的，所以，我就可以将la与oo列于( )当中，并以\|来分隔开来，就可以啦！egrep -n 'g(la\|oo)d' regular_express.txt |
| ()+     | 意义：多个重复群组的判别 范例：将『AxyzxyzxyzxyzC』用echo叫出，然后再使用如下的方法搜寻一下！echo 'AxyzxyzxyzxyzC' \| egrep 'A(xyz)+C'上面的例子意思是说，我要找开头是A 结尾是C ，中间有一个以上的"xyz" 字串的意思～ |

以上两类表达式，就是所有语法了，掌握了这些就掌握了正则表达式这一强大的武器，因为可以用它做各种炫酷的事情，而且很多工具类应用就是通过他来实现的。

**接下来，列出常见的结论和重点：**

- 正则表达式就是处理字串的方法，**他是以行为单位来进行字串的处理行为**；
- 正则表达式透过一些特殊符号的辅助，可以让使用者轻易的达到『搜寻/删除/取代』某特定字串的处理程序；
- 只要工具程序支援正则表达式，那么该工具程序就可以用来作为正则表达式的字串处理之用；
- 正则表达式与通配符是完全不一样的东西！万用字元(wildcard) 代表的是bash 操作介面的一个功能， 但正则表达式则是一种字串处理的表示方式！
- 使用grep 或其他工具进行正则表达式的字串比对时，因为编码的问题会有不同的状态，因此， 你最好将LANG 等变数设定为C 或者是en 等英文语系
- grep 与egrep 在正则表达式里面是很常见的两支程序，其中， egrep 支援更严谨的正则表达式的语法；
- 由于编码系统的不同，不同的语系(LANG) 会造成正则表达式撷取资料的差异。因此可利用特殊符号如[:upper:] 来替代编码范围较佳；
- 由于严谨度的不同，正则表达式之上还有更严谨的延伸正则表达式；
- 基础正则表达式的特殊字符有： *, ., [], [-], [^], ^, $ 等！
- 常见的支援正则表达式的工具软体有： grep , sed, vim 等等
- printf 可以透过一些特殊符号来将资料进行格式化输出；
- awk 可以使用『栏位』为依据，进行资料的重新整理与输出；
- 文件的比对中，可利用diff 及cmp 进行比对，其中diff 主要用在纯文字文件方面的新旧版本比对
- patch 指令可以将旧版资料更新到新版(主要亦由diff 建立patch 的补丁来源文件)





# Shell 脚本

## 什么是shell 脚本

Bash 是我们与系统沟通的一个桥梁，而shell 是Bash的一种代表。

shell script是利用shell的功能所写的一个『程式(program)』，这个程式是使用纯文字档，将一些shell的语法与指令(含外部指令)写在里面，搭配正规表示法、管线命令与资料流重导向等功能，以达到我们所想要的处理目的。

shell 脚本的好处：

1. 可以批处理（类似程序运行一样），而不是只是运行一个命令；
2. 自动化工作，类似jenkens，运维工作等

### 基础语法：

假设你写的这个程式文件名是 /home/dmtsai/shell.sh 好了，那如何执行这个文件？很简单，可以有底下几个方法：

- 直接指令下达： shell.sh 文件必须要具备可读与可执行(rx) 的权限，然后：
  - 绝对路径：使用/home/dmtsai/shell.sh 来下达指令；
  - 相对路径：假设工作目录在/home/dmtsai/ ，则使用./shell.sh 来执行
  - 变数『PATH』功能：将shell.sh 放在PATH 指定的目录内，例如： ~/bin/
- 以bash 程式来执行：透过『 bash shell.sh 』或『 sh shell.sh 』来执行

为何『 sh shell.sh 』也可以执行呢？这是因为/bin/sh其实就是/bin/bash (连结档)，使用sh shell.sh亦即告诉系统，我想要直接以bash的功能来执行shell.sh这个文件内的相关指令的意思，所以此时你的shell.sh只要有r的权限即可被执行喔！



**数学运算**

var=\$((运算内容))  eg：`result=$((2+​3))`

就是说我们涉及到数学计算，必须要放到 $(( )) 里面，否则不生效，各种问题，记住一点要记住这一点。

**不同的执行方式source** ，

通过直接指令下达执行脚本，它会在一个新的bash环境来执行脚本内的指令！也就是说，使用这种执行方式时，其实script是在子程序的bash内执行的，其含义在于：『当子程序完成后，在子程序内的各项变数或动作将会结束而不会传回到父程序中。比如说，我们在脚本中创建了一个变量并赋值，当脚本结束后，在主程序获取那个脚本变量是获取不到的。想要获取的到，需要通过source 来执行，替代sh。 

![showname.sh 在子程序当中运作的示意图](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj1suat82hg309k02pa9v.gif)

**其实语法学习，对比学习了那么多的编程语言，无法就那么几个基本的点：**

变量定义、条件判断语句、循环语句、函数功能、其他特色语法，这些点掌握了也就掌握了shell 脚本的基本语法了，也就会写相应的脚本了。

## 判断语句

对于一个系统而言，它有很多的判断语句，不光像单独一些编程语言仅仅针对数字、逻辑判断，还有其他比如判断文件，文件夹，文件权限等等，下面就列举一些常用的判断语句：



想要测试一下该文件名是啥玩意儿时，还有哪些标志可以来判断的呢？呵呵！有底下这些东西喔！

注意点：使用下面这些表达式，如果需要参数的

| 测试的标志                                                   | 代表意义                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 关于某个文件名的『文件类型』判断，如test -e filename 表示存在否 |                                                              |
| -e                                                           | ==该『文件名』是否存在？(常用)==                             |
| -f                                                           | **该『文件名』是否存在且为文件(file)？(常用)**               |
| -d                                                           | **该『文件名』是否存在且为目录(directory)？(常用)**          |
| -b                                                           | 该『文件名』是否存在且为一个block device 装置？              |
| -c                                                           | 该『文件名』是否存在且为一个character device 装置？          |
| -S                                                           | 该『文件名』是否存在且为一个Socket 文件？                    |
| -p                                                           | 该『文件名』是否存在且为一个FIFO (pipe) 文件？               |
| -L                                                           | 该『文件名』是否存在且为一个连结档？                         |
| 2. 关于文件的权限检测，如test -r filename 表示可读否(但root 权限常有例外) |                                                              |
| -r                                                           | 检测该文件名是否存在且具有『可读』的权限？                   |
| -w                                                           | 检测该文件名是否存在且具有『可写』的权限？                   |
| -x                                                           | 检测该文件名是否存在且具有『可执行』的权限？                 |
| -u                                                           | 检测该文件名是否存在且具有『SUID』的属性？                   |
| -g                                                           | 检测该文件名是否存在且具有『SGID』的属性？                   |
| -k                                                           | 检测该文件名是否存在且具有『Sticky bit』的属性？             |
| -s                                                           | 检测该文件名是否存在且为『非空白文件』？                     |
| 3. 两个文件之间的比较，如： test file1 -nt file2             |                                                              |
| -nt                                                          | (newer than)判断file1 是否比file2 新                         |
| -ot                                                          | (older than)判断file1 是否比file2 旧                         |
| -ef                                                          | 判断file1 与file2 是否为同一文件，可用在判断hard link 的判定上。主要意义在判定，两个文件是否均指向同一个inode 哩！ |
| 4. 关于两个整数之间的判定，例如test n1 -eq n2                |                                                              |
| -eq                                                          | 两数值相等(equal)                                            |
| -ne                                                          | 两数值不等(not equal)                                        |
| -gt                                                          | n1 大于n2 (greater than)                                     |
| -lt                                                          | n1 小于n2 (less than)                                        |
| -ge                                                          | n1 大于等于n2 (greater than or equal)                        |
| -le                                                          | n1 小于等于n2 (less than or equal)                           |
| 5. 判定字符串的资料 **==str1 和 str2 与符号之间不能有空格，否则会有错误==** |                                                              |
| test -z string                                               | 判定字串是否为0 ？若string 为空字串，则为true                |
| test -n string                                               | 判定字串是否非为0 ？若string为空字串，则为false。 注： -n亦可省略 |
| test str1 == str2                                            | 判定str1 是否等于str2 ，若相等，则回传true                   |
| test str1 != str2                                            | 判定str1 是否不等于str2 ，若相等，则回传false                |
| 6. 多重条件判定，例如： test -r filename -a -x filename      |                                                              |
| -a                                                           | (and)两状况同时成立！例如test -r file -a -x file，则file 同时具有r 与 x 权限时，才回传true。 |
| -o                                                           | (or)两状况任何一个成立！例如test -r file -o -x file，则file 具有r 或 x 权限时，就可回传true。 |
| !                                                            | 反相状态，如test ! -x file ，当file 不具有x 时，回传true     |

![image-20200924170927154](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj1us2oo84j30xw03wgm2.jpg)

还有其他的测试点都是可以用的。

#### [] 中括号判断式子

```

//看变量是否为空
shijianhua@sjh-MacPro bash % [ -z "${HOME}" ] ; echo $?
1

```

==上面说的判断语句用于脚本中，每个【】 中的每个运算符之间都要有空格；但是直接去运行好像又不要有空格，比如 ==  、!= 这种字符串判断，反正对这两个特别注意就行了。==

```
if [ 'a' == '1' ] ; then # 这里有空格，否则会错误；即在脚本中就留空格
	echo "true"
else 
	echo "false"
fi
```



中括号的语法注意点：

- 在中括号[] 内的每个元件都需要有空白键来分隔；
- 在中括号内的变数，最好都以双引号括号起来；
- 在中括号内的常数，最好都以单或双引号括号起来。

#### 变量功能

```
//代码
echo "The script name is ==> ${0}"
echo "Total parameter number is ==> $#"
[ "$#" -lt 2 ] && echo "The number of parameter is less than 2. Stop here." && exit 0
echo "Your whole parameter is ==> '$@'"
echo "The 1st parameter ==> ${1}"
echo "The 2nd parameter ==> ${2}"

//输出
shijianhua@sjh-MacPro bash % sh shell_variable.sh one two three four
The script name is ==> shell_variable.sh
Total parameter number is ==> 4
Your whole parameter is ==> 'one two three four'
The 1st parameter ==> one
The 2nd parameter ==> two
shijianhua@sjh-MacPro bash %

```

变量的功能就是我们在执行脚本程序的时候，可以带一些参数，比如上面的代码 `sh shell_variable.sh one two three four` 带了四个参数 one two three four ，这就是变量的功能，下面我们来学习一下。

这个语法是这样的：

```
/path/to/scriptname opt1 opt2 opt3 opt4 
          $0 $1 $2 $3 $4
```

这个scrpitname 就是变量$0 , 也就是文件名称，其他的参数我们可以自己接上，每个参数空格隔开即可。

- $# ：代表后接的参数『个数』，以上表为例这里显示为『 4 』；
- "\$@" ：代表所有的参数（除开$0 ）, 这里就是 one two three four ；
- "\$*" ：\*代表  1 、2 、3 ...  那表示第一个参数、第二个参数、第三个参数，依次类推。



**shift 变量偏移**

上面的程序，最后面添加三行代码为

```
shift
echo "total params ==> '$#'"
echo "display params ==> '$@'"

运行代码为：shijianhua@sjh-MacPro bash % sh shell_variable.sh one two three four
输出为：
The script name is ==> shell_variable.sh
Total parameter number is ==> 4
Your whole parameter is ==> 'one two three four'
The 1st parameter ==> one
The 2nd parameter ==> two
total params ==> '3'
display params ==> 'two three four'
shijianhua@sjh-MacPro bash %
```

shift会移动变量，而且shift后面可以接数字，代表拿掉最前面的几个参数的意思。其实这就是一个语法而已。

## 条件语句if then

这东西说白了，就是其他编程语言的if - else 罢了。这是在shell 用if -then ，好好研究一下吧。

我们前面看了 && || 可以执行正确和错误的语句。但他们的缺点是只能执行单一的语句，假如正确的情况要执行很多的语句，该如何是好呢？

所以就要用到if -then 来实现了。

**单层、简单条件判断式**

只有一个单层的逻辑：

```
if [条件判断式]; then
	当条件判断式成立时，可以进行的指令工作内容；
fi    <==将if反过来写，就成为fi啦！结束if之意！
```

当我们的中括号里面的条件判断式子有多个判断条件时，可以使用

- && 代表AND ；
- || 代表or ；

进行代替。

[ "\${yn}" == "Y" -o "\${yn}" == "y" ] 可替换为 [ "​\${yn}" == "Y" ] || [ "${ yn}" == "y" ]  (yn 为变量。)



**多重、复杂条件判断式**

```
#一个条件判断，分成功进行与失败进行(else) 
if [条件判断式]; then
	当条件判断式成立时，可以进行的指令工作内容；
else
	当条件判断式不成立时，可以进行的指令工作内容；
fi
```

如果考虑更复杂的情况，则可以使用这个语法：

```
#多个条件判断(if ... elif ... elif ... else)分多种不同情况执行
if [条件判断式一]; then
	当条件判断式一成立时，可以进行的指令工作内容；
elif [条件判断式二]; then
	当条件判断式二成立时，可以进行的指令工作内容；
else
	当条件判断式一与二均不成立时，可以进行的指令工作内容；
fi
```

然后总结一下，就是 这样的结构

```
if [判断语句] ;then
		相关逻辑
elif 【判断语句2】;then
   相关逻辑
elif 【判断语句3】;then
....
// 这里可以有0 到n 个elif 语句；
else 
   相关逻辑
// 这里的else 也可以不要   
fi   
```

## Case  

对比java 的 switch-case ，不过其语法是：

```
case $变数名称in    <==关键字为case ，还有变数前有钱字号 
  "第一个变数内容" )    <==每个变数内容建议用双引号括起来，关键字则为小括号)
	程式段
	;;             <==每个类别结尾使用两个连续的分号来处理！
  "第二个变数内容" )
	程式段
	;; 
  * )                   <==最后一个变数内容都会用*来代表所有其他值
	不包含第一个变数内容与第二个变数内容的其他程式执行段
	exit 1
	;; 
esac                   <==最终的case结尾！『反过来写』思考一下！
```

案例：

```

a=2
echo "a的值${a}"
case ${a} in
	2 )
	echo "2 case"
	;;
	"'1'" )
	echo "1 case"
	;;
	*)
	echo "特殊的值"
	;;
esac 

```

一般来说，使用『 case $变数in 』这个语法中，当中的那个『 $变数』大致有两种取得的方式：

- **直接下达式**：例如上面提到的，利用『 script.sh variable 』的方式来直接给予$1这个变数的内容，这也是在/etc/init.d目录下大多数程式的设计方式。
- **互动式**：透过read这个指令来让使用者输入变数的内容。

```
echo "This program will print your selection !"
# read -p "Input your choice: " choice    #暂时取消，可以替换！
# case ${choice} in                       #暂时取消，可以替换！
case ${1} in                              #现在使用，可以用上面两行替换！ 可以用case ${choice} in 这样就是
用输入的变量替代。
  "one")
	echo "Your choice is ONE"
	;;
  "two")
	echo "Your choice is TWO"
	;;
  "three")
	echo "Your choice is THREE"
	;;
  *)
	echo "Usage ${0} {one|two|three}"
	;;
esac
```



## while 循环

我们知道java的while 循环有两种，一种是do——while ，一种 while ，两种用法，对应shell 也是的，不过是

一般来说，不定循环最常见的就是底下这两种状态了：

```
while [ condition ]   <==中括号内的状态就是判断表达式 
do             <==do是循环的开始！
	程式段落
done           <==done是循环的结束

```

while的中文是『当....时』，所以，这种方式说的是『当condition条件成立时，就进行循环，直到condition的条件不成立才停止』的意思。

还有另外一种不定循环的方式：

```
until [ condition ]
do
	程式段落
done 
```

这种方式恰恰与while相反，它说的是『当condition条件成立时，就终止循环，否则就持续进行循环的程式段。』是否刚好相反啊～我们以while来做个简单的练习好了。

Q：假设我要让使用者输入yes或者是YES才结束程式的执行，否则就一直进行告知使用者输入字串。

```
while [ "${yn}" != "yes" -a "${yn}" != "YES" ]; do
	#statements
	read -p "请输入yes或者YES:" yn
done
echo "OK! you input the correct answer."
//注意 [ "${yn}" != "yes" -a "${yn}" != "YES" ] 这里面的表达式要有空格
```



## for 循环

for循环也可以对比java，在java中有一个for循环，一个常规的for循环（比如遍历list等等）

### 增加for循环

```
for var in con1 con2 con3 ... (就是一个集合)
do
	程式段
done
# 例子
users=$(cut -d ':' -f1 /etc/passwd)     #截取帐号名称  users 就是一个集合
for username in ${users}                #开始循环进行！
do
        id ${username}
done
```



### 常规的for循环

```
for ((初始值;限制值;执行步阶))
do
	程式段
done
```

- 初始值：某个变数在回圈当中的起始值，直接以类似i=1 设定好；
- 限制值：当变数的值在这个限制值的范围内，就继续进行回圈。例如i<=100；
- 执行步阶：每作一次回圈时，变数的变化量。例如i=i+1。

比如：求从1到你输入的自然数的和：

```
read -p "Please input a number, I will count for 1+2+...+your_input: " nu

s=0
for (( i=1; i<=${nu}; i=i+1 ))
do
	s=$((${s}+${i}))
done
echo "The result of '1+2+3+...+${nu}' is ==> ${s}"
```

> 除了使用\$(seq 1 100) 之外，你也可以直接使用bash 的内建机制来处理喔！可以使用{1..100} 来取代$(seq 1 100) ！那个大括号内的前面/后面用两个字元，中间以两个小数点来代表连续出现的意思！例如要持续输出a, b, c...g 的话， 就可以使用『 echo {a..g} 』这样的表示方式！

## 函数function

函数的作用就是封装，其定义如下：

```
function fname () {
	程式段
}
```

**function的定义一定要在脚本的最前面**，因为shell script的执行方式是由上而下，由左而右，否则会找不到相应的函数。这个函数和脚本一样，没有参数，可以默认传参数，像脚本那样。然后可以有返回值。

### 返回值的函数

参考资料：https://www.runoob.com/linux/linux-shell-func.html 

```
function method(){
	c=$((1+3))
	return ${c}
}

method  # 执行函数
res1=$? # 获取函数结果
echo "res1的值${res1}" # 使用结果
————————————————————————————————
运行之后的结果
res1的值4
```

### 函数参数

```
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}

```

运行之后输出：`funWithParam 1 2 3 4 5 6 7 8 9 34 73`

```
第一个参数为 1 !
第二个参数为 2 !
第十个参数为 10 !
第十个参数为 34 !
第十一个参数为 73 !
参数总数有 11 个!
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
```

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 \$n 的形式来获取参数的值，例如，​\$1表示第一个参数，​\$2表示第二个参数...​\$10 不能获取第十个参数，获取第十个参数需要\${10}。当n>=10时，需要使用\${n}来获取参数。

> 这一点和脚本参数一样，这也是shell 脚本不同于其他的编程语言。

## debug

这里的debug 和java不一样，他没有那种断电调试，只是一些命令行辅助我们编码；

```
[dmtsai@study ~]$ sh [-nvx] scripts.sh 
选项与参数：
-n ：不要执行script，仅查询语法的问题；
-v ：再执行sccript 前，先将scripts 的内容输出到萤幕上；
-x ：将使用到的script 内容显示到萤幕上，这是很有用的参数！
```