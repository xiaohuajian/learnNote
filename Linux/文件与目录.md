# 文件权限与目录

## 用户与用户组

Linux非常最要的一点就是多人多任务，这个特点使的我们需要对一个文件进行权限管理，所以，文件的权限管理也是非常重要的一点。**linux将文件的身份分为三个类别，拥有者owner、所属群组　group 、其他人other ，他们对文件具有不同的读、写、执行权限**。下面举一例子，可以类比我们用ｓｖｎ、ｇｉｔ这种版本管理工具进行文件管理时对不同人具有不同的权限一样。比如说：在开发一个新功能，项目组长Ａ创建了一个工程，并把这个工程代码文件相应的权限给了同组人，同时组Ｂ成员则无法访问刚才的工程；以上场景进行映射就是　项目组长是ｏｗｎｅｒ，该组的人是同属一个群组ｇｒｏｕｐ；其他组的人就是ｏｔｈｅｒ；组长可以对组内的人授予读写权限，可以对其他人设置只读权限、或者完全不可见。有一位系统管理员可以看到所有组创建的工程和代码，那就是超级管理员root；

> 在我们Linux系统当中，默认的情况下，所有的系统上的账号与一般身份使用者，还有那个root的相关信息， 都是记录在/etc/passwd这个文件内的。至于个人的密码则是记录在/etc/shadow这个文件下。 此外，Linux所有的组名都纪录在/etc/group内

## 权限概念

打开终端命令行，输入　`ls -al`，会显示下面信息：

```
[root@www ~]# ls -al
total 156
drwxr-x---   4    root   root     4096   Sep  8 14:06 .
drwxr-xr-x  23    root   root     4096   Sep  8 14:21 ..
-rw-------   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg
-rw-------   1    root   root      199   Sep  8 17:14 .bash_history
-rw-r--r--   1    root   root       24   Jan  6  2007 .bash_logout
-rw-r--r--   1    root   root      191   Jan  6  2007 .bash_profile
-rw-r--r--   1    root   root      176   Jan  6  2007 .bashrc
-rw-r--r--   1    root   root      100   Jan  6  2007 .cshrc
drwx------   3    root   root     4096   Sep  5 10:37 .gconf      <=范例说明处
drwx------   2    root   root     4096   Sep  5 14:09 .gconfd
-rw-r--r--   1    root   root    42304   Sep  4 18:26 install.log <=范例说明处
-rw-r--r--   1    root   root     5661   Sep  4 18:25 install.log.syslog
[    1   ][  2 ][   3  ][  4 ][    5   ][     6     ][       7          ]
[  权限  ][连结][拥有者][群组][文件容量][  修改日期 ][      檔名        ]
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://img-blog.csdnimg.cn/20191208231329374.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

第一栏代表这个文件的类型与权限(permission)：

这个地方最需要注意了！仔细看的话，你应该可以发现这一栏其实共有十个字符。

![img](https://img-blog.csdnimg.cn/20191208231435423.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

- 第一个字符代表这个文件是『目录、文件或链接文件等等』：

  - 当为[ d ]则是目录，例如[上表](http://cn.linux.vbird.org/linux_basic/0210filepermission_2.php#table2.1.1)档名为『.gconf』的那一行；
  - 当为[ - ]则是文件，例如[上表](http://cn.linux.vbird.org/linux_basic/0210filepermission_2.php#table2.1.1)档名为『install.log』那一行；
  - 若是[ l ]则表示为连结档(link file)；
  - 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
  - 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

- 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。

  - 第一组为『文件拥有者的权限』，以『install.log』那个文件为例， 该文件的拥有者可以读写，但不可执行；
  - 第二组为『同群组的权限』；
  - 第三组为『其他非本群组的权限』

  |             | 内容         | 叠代物件   | r            | w            | x                     |
  | ----------- | ------------ | ---------- | ------------ | ------------ | --------------------- |
  | 文件        | 详细资料data | 文件资料夹 | 读到文件内容 | 修改文件内容 | 执行文件内容          |
  | 目录/文件夹 | 档名         | 可分类抽屉 | 读到档名     | 修改档名     | 进入该目录的权限(key) |

- 第二栏表示有多少档名连结到此节点(i-node)

- 第三栏表示这个文件(或目录)的『拥有者账号』

- 第四栏表示这个文件的所属群组

- 在Linux系统下，你的账号会附属于一个或多个的群组中。举刚刚我们提到的例子，class1, class2, class3均属于projecta这个群组，假设某个文件所属的群组为projecta，且该文件的权限如图2.1.2所示(-rwxrwx---)， 则class1, class2, class3三人对于该文件都具有可读、可写、可执行的权限(看群组权限)。 但如果是不属于projecta的其他账号，对于此文件就不具有任何权限了。

- 第五栏为这个文件的容量大小，默认单位为bytes；

- 第六栏为这个文件的建档日期或者是最近的修改日期：

  - 这一栏的内容分别为日期(月/日)及时间。如果这个文件被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。 如下所示：

    `[root@www ~]# ls -l /etc/termcap /root/install.log-rw-r--r-- 1 root root 807103 Jan  7  2007 /etc/termcap-rw-r--r-- 1 root root  42304 Sep  4 18:26 /root/install.log# 如上所示，/etc/termcap 为 2007 年所修改过的文件，离现在太远之故；# 至于 install.log 是今年 (2009) 所建立的，所以就显示完整的时间了。`

    如果想要显示完整的时间格式，可以利用ls的选项，亦即：『ls -l --full-time』就能够显示出完整的时间格式了！包括年、月、日、时间喔。 另外，如果你当初是以繁体中文安装你的Linux系统，那么日期字段将会以中文来显示。 可惜的是，中文并没有办法在纯文本的终端机模式中正确的显示，所以此栏会变成乱码。 那你就得要使用『LANG=en_US』来修改语系喔！

- 第七栏为这个文件名字

### Linux文件权限的重要性：

与Windows系统不一样的是，在Linux系统当中，每一个文件都多加了很多的属性进来，尤其是群组的概念，这样有什么用途呢？ 其实，最大的用途是在『数据安全性』上面的。

- **系统保护的功能：**
  举个简单的例子，在你的系统中，关于系统服务的文件通常只有root才能读写或者是执行，例如/etc/shadow这一个账号管理的文件，由于该文件记录了你系统中所有账号的数据， 因此是很重要的一个配置文件，当然不能让任何人读取(否则密码会被窃取啊)，只有root才能够来读取啰！所以该文件的权限就会成为[ -rw------- ]啰！

  

- **团队开发软件或数据共享的功能：**
  此外，如果你有一个软件开发团队，在你的团队中，你希望每个人都可以使用某一些目录下的文件， 而非你的团队的其他人则不予以开放呢？以上面的例子来说，testgroup的团队共有三个人，分别是test1, test2, test3，那么我就可以将团队所需的文件权限订为[ -rwxrwx--- ]来提供给testgroup的工作团队使用啰！

  

- **未将权限设定妥当的危害：**
  例如本来只有root才能做的开关机、ADSL的拨接程序、新增或删除用户等等的指令，若被你改成任何人都可以执行的话， 那么如果使用者不小心给你重新启动啦！重新拨接啦！等等的！那么你的系统不就会常常莫名其妙的挂掉啰！ 而且万一你的用户的密码被其他不明人士取得的话，只要他登入你的系统就可以轻而易举的执行一些root的工作！

###  修改文件权限

- chgrp（change group ） ：改变档案所属群组 
- chown （change owner）：改变档案拥有者
- chmod （change modify）：改变档案的权限

**chmod**

**1 数字类型改变档案权限**

Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限；然后

r:4
w:2
x:1

```
[root@study ~]# chmod [-R] xyz档案或目录 eg：chmod -R 777 fileName 
选项与参数：
xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。
-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更
```

2 **符号类型改变档案权限**

九个权限分别是(1)user (2)group (3)others三种身份啦！那么我们就可以藉由**u, g, o**来代表三种身份的权限！此外，**a**则代表all亦即全部的身份:

| chmod | u <br />g<br />o<br />a | +(加入)<br /> -(除去) <br />=(设定) | r<br />w <br />x | 文件或目录 |
| ----- | ----------------------- | ----------------------------------- | ---------------- | ---------- |
|       |                         |                                     |                  |            |

```

[root@study ~]# chmod u=rwx,go=rx .bashrc 
#注意喔！那个u=rwx,go=rx是连在一起的，中间并没有任何空白字元！
chmod a+w .bashrc 

```

### 常见文件扩展名

- *.sh ： 脚本或批次档(scripts)，因为批次档为使用shell写成的，所以副档名就编成.sh 啰；
- *Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩档。这是因为压缩软体分别为gunzip, tar 等等的，由于不同的压缩软体，而取其相关的扩展名啰！

### 常见命令

|      | /etc/passwd	        保存用户信息                          |
| ---- | ------------------------------------------------------------ |
|      | /etc/shadow	        保存用户密码                          |
|      | /etc/group	        保存用户组                             |
|      | ------------------------------------------------------------------ |
|      | ls -al		        列出所有的档案详细权限与属性 (包含隐藏文件) |
|      | cp		        拷贝档案                                   |
|      | cd		        变更目录                                   |
|      | mkdir		        建立目录                                |
|      | touch		        建立空档案                              |
|      | su		        切换用户(switch user)                      |
|      | rm		        删除目录或档楼(remove)                     |
|      | cat                     读取档案内容                         |
|      | uname                   打印系统信息                         |
|      | lsb_release             显示LSB和特定版本的相关信息          |

## 目录配置FHS

FHS—— Filesystem Hierarchy Standard (FHS) 目录标准。主要为了规范各个目录的作用及含义。说白了，就是让使用者可以了解到已安装软体通常放置于那个目录下。

FHS是根据过去的经验一直再持续的改版的，FHS依据档案系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：

|                            | 可分享的(shareable)        | 不可分享的(unshareable) |
| -------------------------- | -------------------------- | ----------------------- |
| 不变的(static)             | /usr (软体放置处)          | /etc (设定档)           |
| /opt (第三方协力软体)      | /boot (开机与核心档)       |                         |
| 可变动的(variable)         | /var/mail (使用者邮件信箱) | /var/run (程序相关)     |
| /var/spool/news (新闻群组) | /var/lock (程序相关)       |                         |

什么是那四个类型？

- 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行档与使用者的邮件等资料，是能够分享给网路上其他主机挂载用的目录；
- 不可分享的：自己机器上面运作的装置档案或者是与程序有关的socket档案等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。
- 不变的：有些资料是不会经常变动的，跟随着distribution而不变动。例如函式库、文件说明档、系统管理员所管理的主机服务设定档等等；
- 可变动的：经常改变的资料，例如登录档、一般用户可自行收受的新闻群组等。

FHS针对目录树架构仅定义出三层目录底下应该放置什么资料而已，分别是底下这三个目录的定义：

- / (root, 根目录)：与开机系统有关；
- /usr (unix software resource)：与软体安装/执行有关；
- /var (variable)：与系统运作过程有关。

### 根目录 /

所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。==因此建议根目录越小越好，这样发生错误的概率就会越小。==

常见目录名称和其作用：

| 目录       | 应放置档案内容                                               |
| ---------- | ------------------------------------------------------------ |
|            | ==第一部份：FHS 要求必须要存在的目录==                       |
| /bin       | ==系统有很多放置执行档的目录，但/bin比较特殊==。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。 |
| /boot      | ==这个目录主要在放置开机会使用到的档案==，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub2这个开机管理程式，则还会存在/boot/grub2/这个目录喔！ |
| /dev       | 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中的。你只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/loop*, / dev/sd*等等 |
| /etc       | ==系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等==。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行档(binary)在这个目录中喔。比较重要的档案有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等。另外FHS还规范几个重要的目录最好要存在/etc/目录下喔：<br />/etc/opt(必要)：这个目录在放置第三方协力软体/opt的相关设定档/etc/X11/(建议)：与X Window有关的各种设定档都在这里，尤其是xorg.conf这个X Server的设定档。/etc/sgml/(建议)：与SGML格式有关的各项设定档/etc/xml/(建议)：与XML格式有关的各项设定档 |
| /lib       | 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程式的执行之意。另外FHS还要求底下的目录必须要存在：<br />/lib/modules/：这个目录主要放置可抽换式的核心相关模组(驱动程式)喔！ |
| /media     | media是『媒体』的英文，顾名思义，==这个/media底下放置的就是可移除的装置啦==！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。 |
| /mnt       | 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 |
| /opt       | ==这个是给第三方协力软件放置的目录==。什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ |
| /run       | 早期的FHS 规定系统开机后所产生的各项资讯应该要放置到/var/run 目录下，新版的FHS 则规范到/run 底下。由于/run 可以使用记忆体来模拟，因此效能上会好很多！ |
| /sbin      | Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他使用者最多只能用来『查询』而已。 ==放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令==。 至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。 |
| /srv       | srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。常见的服务例如WWW, FTP等等。举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。不过，系统的服务资料如果尚未要提供给网际网路任何人浏览的话，预设还是建议放置到/var/lib 底下即可。 |
| /tmp       | 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除唷！ |
| /usr       | 第二层FHS 设定，后续介绍                                     |
| /var       | 第二曾FHS 设定，主要为放置变动性的资料，后续介绍             |
|            | ==**第二部份：FHS 建议可以存在的目录**==                     |
| /home      | 这是系统预设的使用者家目录(home directory)。在你新增一个一般使用者帐号时， 预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号喔：<br />~：代表目前这个使用者的家目录 <br />~ dmtsai：则代表dmtsai的家目录！ |
| /lib<qual> | 用来存放与/lib 不同的格式的二进位函式库，例如支援64 位元的/lib64 函式库等 |
| /root      | 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。 |



### /usr Unix Software Resource

usr 指的是软件资源，而非用户相关，这个目录等价于windows 的 『C:\Windows\ (当中的一部份) + C:\Program files \』这两个目录的综合体，就是安装系统软件和用户自己安装的软件，由于安装了很多软件，所以也会占用大量的硬盘空间。该文件夹下应当有以下目录：

| 目录            | 应放置档案内容                                               |
| --------------- | ------------------------------------------------------------ |
|                 | 第一部份：FHS 要求必须要存在的目录                           |
| /usr/bin/       | 所有一般用户能够使用的指令都放在这里！目前新的CentOS 7 已经将全部的使用者指令放置于此，而使用连结档的方式将/bin 连结至此！也就是说， /usr/bin 与/bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！ |
| /usr/lib/       | 基本上，与/lib 功能相同，所以/lib 就是连结到此目录中的！     |
| /usr/local/     | 系统管理员在本机自行安装自己下载的软体(非distribution预设提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软体较旧，你想安装较新的软体但又不想移除旧版， 此时你可以将新版软体安装于/usr/local/目录下，可与原先的旧版软体有分别啦！你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！ |
| /usr/sbin/      | 非系统正常运作所需要的系统指令。最常见的就是某些网路伺服器软体的服务指令(daemon)啰！不过基本功能与/sbin 也差不多， 因此目前/sbin 就是连结到此目录中的。 |
| /usr/share/     | 主要放置唯读架构的资料档案，当然也包括共享文件。在这个目录下放置的资料几乎是不分硬体架构均可读取的资料， 因为几乎都是文字档案嘛！在此目录下常见的还有这些次目录：/usr/share/man：线上说明文件/usr/share/doc：软体杂项的文件说明/usr/share/zoneinfo：与时区有关的时区档案 |
|                 | 第二部份：FHS 建议可以存在的目录                             |
| /usr/games/     | 与游戏比较相关的资料放置处                                   |
| /usr/include/   | c/c++等程式语言的档头(header)与包含档(include)放置处，当我们以tarball方式(*.tar.gz 的方式安装软体)安装某些资料时，会使用到里头的许多包含档喔！ |
| /usr/libexec/   | 某些不被一般使用者惯用的执行档或脚本(script)等等，都会放置在此目录中。例如大部分的X视窗底下的操作指令，很多都是放在此目录下的。 |
| /usr/lib<qual>/ | 与/lib<qual>/功能相同，因此目前/lib<qual> 就是连结到此目录中 |
| /usr/src/       | 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 |

### /var 

如果/usr是安装时会占用较大硬碟容量的目录，那么/var就是在系统运作后才会渐渐占用硬碟容量的目录。因为/var目录主要针对常态性变动的档案，包括快取(cache)、登录档(log file)以及某些软体运作所产生的档案， 包括程序档案(lock file, run file)，或者例如MySQL资料库的档案等等

| 目录        | 应放置档案内容                                               |
| ----------- | ------------------------------------------------------------ |
|             | 第一部份：FHS 要求必须要存在的目录                           |
| /var/cache/ | 应用程式本身运作过程中会产生的一些暂存档；                   |
| /var/lib/   | 程式本身执行的过程中，需要使用到的资料档案放置的目录。在此目录下各自的软体应该要有各自的目录。举例来说，MySQL的资料库放置到/var/lib/mysql/而rpm的资料库则放到/var/lib/rpm去！ |
| /var/lock/  | 某些装置或者是档案资源一次只能被一个应用程式所使用，如果同时有两个程式使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软体所使用。举例来说，烧录机正在烧录一块光碟，你想一下，会不会有两个人同时在使用一个烧录机烧片？如果两个人同时烧录，那片子写入的是谁的资料？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。目前此目录也已经挪到/run/lock 中！ |
| /var/log/   | 重要到不行！这是登录档放置的目录！里面比较重要的档案如/var/log/messages, /var/log/wtmp(记录登入者的资讯)等。 |
| /var/mail/  | 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！通常这两个目录是互为连结档啦！ |
| /var/run/   | 某些程式或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。与/run 相同，这个目录连结到/run 去了！ |
| /var/spool/ | 这个目录通常放置一些伫列资料，所谓的『伫列』就是排队等待其他程式使用的资料啦！ 这些资料被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中，但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中，等到被送出后就被删除。如果是工作排程资料(crontab)，就会被放置到/var/spool/cron/目录中！ |

### 目录树

![image-20200826161744454](https://tva1.sinaimg.cn/large/007S8ZIlgy1gi4abdk7v7j30u0140hdt.jpg)



## 绝对/相对路径

- 绝对路径：由根目录(/)开始写起的档名或目录名称，例如/home/dmtsai/.bashrc；
- 相对路径：相对于目前路径的档名写法。例如./home/dmtsai或../../home/dmtsai/等等。==反正开头不是/就属于相对路径的写法==

相对路径是以『你当前所在路径的相对位置』来表示的。举例来说，你目前在/home 这个目录下， 如果想要进入/var/log 这个目录时，可以怎么写呢？

1. cd /var/log (absolute)
2. cd ../var/log (relative)

因为你在/home 底下，所以要回到上一层(../) 之后，才能继续往/var 来移动的！特别注意这两个特殊的目录：

- . ：代表当前的目录，也可以使用./ 来表示；
- .. ：代表上一层目录，也可以../ 来代表。

这个. 与.. 目录概念是很重要的，你常常会看到cd .. 或./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态喔！很重要的呐！



# 文件、目录管理

## 目录与路径

```
. 代表此层目录
.. 代表上一层目录
- 代表前一个工作目录
~ 代表『目前使用者身份』所在的家目录
~account 代表account 这个使用者的家目录(account是个帐号名称)
```

常见的处理目录的指令：

- cd：变换目录
- pwd：显示目前的目录
- mkdir：建立一个新的目录
- rmdir：删除一个空的目录**(只能删除空目录)**

------

**cd (change directory, 变换目录)**

dmtsai这个使用者的家目录是/home/dmtsai/，而root家目录则是/root/，假设我以root身份在Linux系统中，那么简单的说明一下这几个特殊的目录的意义是：

```
[dmtsai@study ~]$ su -   #先切换身份成为root看看！
[root@study ~]# cd [相对路径或绝对路径] 
#最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！
[root@study ~]# cd ~dmtsai 
#代表去到dmtsai这个使用者的家目录，亦即/home/dmtsai 
[root@study dmtsai]# cd ~ 
#表示回到自己的家目录，亦即是/ root这个目录 
[root@study ~]# cd 
#没有加上任何路径，也还是代表回到自己家目录的意思喔！
[root@study ~]# cd .. 
#表示去到目前的上层目录，亦即是/root的上层目录的意思； 
[root@study /]# cd - 
#表示回到刚刚的那个目录，也就是/root啰～ 
[root@study ~]# cd /var/spool/mail 
#这个就是绝对路径的写法！直接指定要去的完整路径名称！
[root@study mail]# cd ../postfix
# 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/postfix 就这样写！
```

**pwd (显示目前所在的目录)**

pwd是Print Working Directory的缩写，也就是显示目前所在目录的指令

**mkdir (建立新目录)**

(make directory) 创建目录。通过 -p 来递归创建多级目录，另外，目录还有一个很重要的东西就是权限，所以需要指明权限，若没有指明就使用默认权限，这个东西就是umask。

```
[root@study ~]# mkdir [-mp]目录名称
选项与参数：
-m ：设定档案的权限喔！直接设定，不需要看预设权限(umask) 的脸色～
-p ：帮助你直接将所需要的目录(包含上层目录)递回建立起来！

范例：请到/tmp底下尝试建立数个新目录看看： 
[root@study ~]# cd /tmp 
[root@study tmp]# mkdir test     <==建立一名为test的新目录 
[root@study tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory 'test1/test2/test3/test4': No such file or directory
#话说，系统告诉我们，没可能建立这个目录啊！就是没有目录才要建立的！见鬼嘛？
[root@study tmp]# mkdir -p test1/test2/test3/test4 
#原来是要建test4上层没先建test3之故！加了这个-p的选项，可以自行帮你建立多层目录！

范例：建立权限为rwx--x--x的目录 
[root@study tmp]# mkdir -m 711 test2 
[root@study tmp]# ls -ld test*
drwxr-xr-x. 2 root root 6 Jun 4 19:03 test
drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1
drwx--x--x . 2 root root 6 Jun 4 19:05 test2
 #仔细看上面的权限部分，如果没有加上-m来强制设定属性，系统会使用预设属性。
#那么你的预设属性为何？这要透过底下介绍的umask才能了解喔！^_^
```

## 文件目录管理

文件与目录的管理上，不外乎『显示属性』、 『拷贝』、『删除文件』及『移动文件或目录』等等；

### 查看 ls

```
[root@study ~]# ls [-aAdfFhilnrRSt]档名或目录名称.. 
[root@study ~]# ls [--color={never,auto,always}]档名或目录名称.. 
[root@ study ~]# ls [--full-time]档名或目录名称.. 
选项与参数：
 -a ：全部的档案，连同隐藏档(开头为.的档案)一起列出来(常用)
-A ：全部的档案，连同隐藏档，但不包括. 与.. 这两个目录
-d ：仅列出目录本身，而不是列出目录内的档案资料(常用)
-f ：直接列出结果，而不进行排序(ls 预设会以档名排序！)
-F ：根据档案、目录等资讯，给予附加资料结构，例如：
      *:代表可执行档； /:代表目录； =:代表socket 档案； |:代表FIFO 档案；
-h ：将档案容量以人类较易读的方式(例如GB, KB 等等)列出来；
-i ：列出inode 号码，inode 的意义下一章将会介绍；
-l ：长资料串列出，包含档案的属性与权限等等资料；(常用)
-n ：列出UID 与GID 而非使用者与群组的名称(UID与GID会在帐号管理提到！)
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；
-R ：连同子目录内容一起列出来，等于该目录下的所有档案都会显示出来；
-S ：以档案容量大小排序，而不是用档名排序；
-t ：依时间排序，而不是用档名。
--color=never ：不要依据档案特性给予颜色显示；
--color=always ：显示颜色
--color=auto ：让系统自行依据设定来判断是否给予颜色
--full-time ：以完整时间模式(包含年、月、日、时、分) 输出
--time={atime,ctime} ：输出access 时间或改变权限属性时间(ctime) 
                       而非内容变更时间(modification time)
```



`ls -al --full-time ; ls -al ~`

### 复制、删除、移动

复制

```
[root@study ~]# cp [-adfilprsu]来源档(source)目标档(destination) 
[root@study ~]# cp [options] source1 source2 source3 .... directory 
选项与参数：
 -a ：相当于-dr --preserve=all的意思，至于dr请参考下列说明；(常用)
-d ：若来源档为连结档的属性(link file)，则复制连结档属性而非档案本身；
-f ：为强制(force)的意思，若目标档案已经存在且无法开启，则移除后再尝试一次；
-i ：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
-l ：进行硬式连结(hard link)的连结档建立，而非复制档案本身；
-p ：连同档案的属性(权限、用户、时间)一起复制过去，而非使用预设属性(备份常用)；
-r ：递回持续复制，用于目录的复制行为；(常用)
-s ：复制成为符号连结档(symbolic link)，亦即『捷径』档案；
-u ：destination 比source 旧才更新destination，或destination 不存在的情况下才复制。
--preserve=all ：除了-p 的权限相关参数外，还加入SELinux 的属性, links, xattr 等也复制了。
最后需要注意的，如果来源档有两个以上，则最后一个目的档一定要是『目录』才行！
```

删除

```
root@study ~]# rm [-fir]档案或目录
选项与参数：
-f ：就是force 的意思，忽略不存在的档案，不会出现警告讯息；
-i ：互动模式，在删除前会询问使用者是否动作
-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！

范例一：将刚刚在cp的范例中建立的bashrc删除掉！
[root@study ~]# cd /tmp 
[root@study tmp]# rm -i bashrc 
rm: remove regular file `bashrc'? y 
#如果加上-i的选项就会主动询问喔，避免你删除到错误的档名！

范例二：透过万用字元*的帮忙，将/tmp底下开头为bashrc的档名通通删除： 
[root@study tmp]# rm -i bashrc* 
#注意那个星号，代表的是0到无穷多个任意字元喔！很好用的东西！

范例三：将cp范例中所建立的/tmp/etc/这个目录删除掉！
[root@study tmp]# rmdir /tmp/etc 
rmdir: failed to remove '/tmp/etc': Directory not empty    <==删不掉啊！因为这不是空的目录！
[root@study tmp]# rm -r /tmp/etc 
rm: descend into directory `/tmp/etc'? y 
rm: remove regular file `/tmp/etc/fstab'? y 
rm: remove regular empty file `/ tmp/etc/crypttab'? ^C   <==按下[ctrl]+c中断
.....(中间省略).....
# 因为身份是root ，预设已经加入了-i 的选项，所以你要一直按y 才会删除！
# 如果不想要继续按y ，可以按下『 [ctrl]-c 』来结束rm 的工作。
#这是一种保护的动作，如果确定要删除掉此目录而不要询问，可以这样做： 
[root@study tmp]# \rm -r /tmp/etc 
#在指令前加上反斜线，可以忽略掉alias的指定选项喔！至于alias我们在bash再谈！
# 拜托！这个范例很可怕！你不要删错了！删除/etc 系统是会挂掉的！
```

移动

```
[root@study ~]# mv [-fiu] source destination 
[root@study ~]# mv [options] source1 source2 source3 .... directory 
选项与参数：
-f ：force 强制的意思，如果目标档案已经存在，不会询问而直接覆盖；
-i ：若目标档案(destination) 已经存在时，就会询问是否覆盖！
-u ：若目标档案已经存在，且source 比较新，才会更新(update)

范例一：复制一档案，建立一目录，将档案移动到目录中 
[root@study ~]# cd /tmp 
[root@study tmp]# cp ~/.bashrc bashrc 
[root@study tmp]# mkdir mvtest 
[ root@study tmp]# mv bashrc mvtest 
#将某个档案移动到某个目录去，就是这样做！

范例二：将刚刚的目录名称更名为mvtest2 
[root@study tmp]# mv mvtest mvtest2  <==这样就更名了！简单～
#其实在Linux底下还有个有趣的指令，名称为rename，
# 该指令专职进行多个档名的同时更名，并非针对单一档名变更，与mv不同。请man rename。

范例三：再建立两个档案，再全部移动到/tmp/mvtest2当中 
[root@study tmp]# cp ~/.bashrc bashrc1 
[root@study tmp]# cp ~/.bashrc bashrc2 
[root@study tmp] # mv bashrc1 bashrc2 mvtest2 
#注意到这边，如果有多个来源档案或目录，则最后一个目标档一定是『目录！』
# 意思是说，将所有的资料移动到该目录的意思！
```

## 查看文档内容

- cat 由第一行开始显示档案内容
- tac 从最后一行开始显示，可以看出tac 是cat 的倒着写！
- nl 显示的时候，顺道输出行号！
- more 一页一页的显示档案内容
- less 与more 类似，但是比more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行
- od 以二进位的方式读取档案内容！

然后还有一些查找的窍门技巧如下：

**翻页查找**：more、less

进入翻页模式后，输入/ 用q 离开，即可。

**数据截取**：head、tail (从头和从尾截取)

`head/tail  [-n number] fileName`

```
root@study ~]# head [-n number]档案
选项与参数：
-n ：后面接数字，代表显示几行的意思

[root@study ~]# head /etc/man_db.conf 
#预设的情况中，显示前面十行！若要显示前20行，就得要这样： 
[root@study ~]# head -n 20 /etc/man_db.conf
```

比如说我想截取某个文件的第10行到20行；

可以运用命令 `head -n  20  fileName | tail -n 10`  这样就可以了。这里的 ｜ 是管道操作命令。

### 修改文件时间或创建文件Touch

 touch 这个指令最常被使用的情况是：

- 建立一个空的档案；
- 将某个档案日期修订为目前(mtime 与atime)

一般的，文件有多个时间，修改时间、状态时间、读取时间；

- **modification time (mtime)**：
  当该档案的『内容资料』变更时，就会更新这个时间！内容资料指的是档案的内容，而不是档案的属性或权限喔！
- **status time (ctime)**：
  当该档案的『状态(status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。
- **access time (atime)**：
  当『该档案的内容被取用』时，就会更新这个读取时间(access)。举例来说，我们使用cat去读取/etc/man_db.conf ，就会更新该档案的atime了。

ls命令显示出来的是该档案的mtime ，也就是这个档案的内容上次被更动的时间。

```
[root@study ~]# touch [-acdmt]档案
选项与参数：
-a ：仅修订access time；
-c ：仅修改档案的时间，若该档案不存在则不建立新档案；
-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用--date="日期或时间"
-m ：仅修改mtime ；
-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]

范例一：新建一个空的档案并观察时间 
[dmtsai@study ~]# cd /tmp 
[dmtsai@study tmp]# touch testtouch 
[dmtsai@study tmp]# ls -l testtouch 
-rw-rw-r--. 1 dmtsai dmtsai 0 Jun 16 00:45 testtouch
 #注意到，这个档案的大小是0呢！在预设的状态下，如果touch后面有接档案，
# 则该档案的三个时间(atime/ctime/mtime) 都会更新为目前的时间。若该档案不存在，
# 则会主动的建立一个新的空的档案喔！例如上面这个例子！

范例二：将~/.bashrc复制成为bashrc，假设复制完全的属性，检查其日期 
[dmtsai@study tmp]# cp -a ~/.bashrc bashrc 
[dmtsai@study tmp]# date; ll bashrc; ll - -time=atime bashrc; ll --time=ctime bashrc 
Tue Jun 16 00:49:24 CST 2015                          <==这是目前的时间 
-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 bashrc   <==这是mtime 
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15 23:44 bashrc   <==这是atime 
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00 :47 bashrc   <==这是ctime
```

在上面这个案例当中我们使用了『ll』这个指令(两个英文L的小写)，这个指令其实就是『ls -l』的意思， ll本身不存在，是被『做出来』的一个命令别名。这里先知道ll="ls -l"即可。至于分号『 ; 』则代表连续指令的下达啦！你可以在一行指令当中写入多重指令，这些指令可以『依序』执行。由上面的指令我们会知道ll那一行有三个指令被下达在同一行中。

## 文件默认权限和隐藏权限

文件的权限有读写执行（rwx），以及是否是目录、文件或者链接属性。单纯的读写执行权限无法满足我们的基本要求，因此对应有了特殊权限位（SUID、SGID、SBIT），这些权限 位用来弥补一般权限不能实现的功能，帮助没有权限的用户执行需要root权限的工作。

### 文件默认权限 umask

当你建立一个新的文件或目录时，他的预设权限会是什么吗？呵呵！那就与umask这个玩意儿有关了！那么umask是在搞什么呢？

**在预设权限的属性上，目录与文件是不一样的**。从第五章我们知道x 权限对于目录是非常重要的！但是一般文件的建立则不应该有执行的权限，因为一般文件通常是用在于资料的记录嘛！当然不需要执行的权限了。因此，预设的情况如下：

- 若使用者建立为『文件』则预设『没有可执行( x )权限』，亦即只有rw这两个项目，也就是最大为666分，预设权限如下：
  **-rw-rw-rw-**
- 若使用者建立为『目录』，则由于x与是否可以进入此目录有关，因此预设为所有权限均开放，亦即为777分，预设权限如下：
  **drwxrwxrwx**

注意的是，umask的分数指的是『该预设值需要减掉的权限！』,r、w、x分别是4、2、1分, 当我们运行 umask ，会得到一个分数

```
shijianhua@sjh-MacPro resume % umask
022
shijianhua@sjh-MacPro resume % umask -S
u=rwx,g=rx,o=rx
```

就是 666/777 （根据是文件或目录）减去这个umask 所显示的分数。

以上面的例子来说明的话，因为umask 为022 ，所以user 并没有被拿掉任何权限，不过group 与others 的权限被拿掉了2 (也就是w 这个权限)，那么当使用者：

- 建立文件时：(-rw-rw-rw-) - (-----w--w-) ==> -rw-r--r--
- 建立目录时：(drwxrwxrwx) - (d----w--w-) ==> drwxr-xr-x

### 文件特殊权限

SUID、SGID、DBIT

具体内容可以看 http://linux.vbird.org/linux_basic/0220filemanager.php

## 文件查找

### which 脚本文件

which 可以找出在PATH 配置了环境变量的文件命令。即这个指令是根据『[PATH](http://linux.vbird.org/linux_basic/0220filemanager.php#dir_path)』这个环境变量所规范的路径，去搜寻『执行文件』的文件名

```
[root@study ~]# which [-a] command 
选项或参数：
-a ：将所有由PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称

范例一：搜寻ifconfig这个指令的完整档名 
[root@study ~]# which ifconfig
/sbin/ifconfig 

范例二：用which去找出which的档名为何？
[root@study ~]# which which
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
        /bin/alias
        /usr/bin/which
# 竟然会有两个which ，其中一个是alias 这玩意儿呢！那是啥？
# 那就是所谓的『命令别名』，意思是输入which 会等于后面接的那串指令啦！
# 更多的资料我们会在bash 章节中再来谈的！

范例三：请找出history这个指令的完整档名 
[root@study ~]# which history
/usr/bin/which: no history in (/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin:/root/bin)
```

### 文件查找

**whereis (由一些特定的目录中寻找档案档名)**

由于whereis 只会在特定的目录，针对/bin /sbin 底下的执行文件， 以及/usr/share/man 底下的man page 文件；

```
[root@study ~]# whereis [-bmsu]档案或目录名
选项与参数：
-l :可以列出whereis 会去查询的几个主要目录而已
-b :只找binary 格式的档案
-m :只找在说明档manual 路径下的档案
-s :只找source 来源档案
-u :搜寻不在上述三个项目当中的其他特殊档案

范例一：请找出ifconfig这个档名 
[root@study ~]# whereis ifconfig
ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz

范例二：只找出跟passwd有关的『说明文件』档名(man page) 
[root@study ~]# whereis passwd      #全部的档名通通列出来！
passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
[root@study ~]# whereis -m passwd   #只有在man里面的档名才抓出来！
passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
```

**locate / updatedb**

```
[root@study ~]# locate [-ir] keyword 
选项与参数：
-i ：忽略大小写的差异；
-c ：不输出档名，仅计算找到的档案数量
-l ：仅输出几行的意思，例如输出五行则是-l 5
-S ：输出locate 所使用的资料库档案的相关资讯，包括该资料库纪录的档案/目录数量等
-r ：后面可接正规表示法的显示方式

范例一：找出系统中所有与passwd相关的档名，且只列出5个 
[root@study ~]# locate -l 5 passwd
/etc/passwd
/etc/passwd-
/etc/pam.d/passwd
/etc/security/opasswd
/usr/bin/gpasswd

范例二：列出locate查询所使用的资料库档案之档名与各资料数量 
[root@study ~]# locate -S
Database /var/lib/mlocate/mlocate.db:
        8,086 directories      #总纪录目录数 
        109,605 files          #总纪录档案数
        5,190,295 bytes in file names
        2,349,150 bytes used to store database
```

locate 的使用更简单，直接在后面输入『文件的部分名称』后，就能够得到结果。举上面的例子来说，我输入locate passwd ，那么在完整档名(包含路径名称) 当中，只要有passwd 在其中， 就会被显示出来的；

使用locate来寻找资料的时候特别的快，这是因为locate寻找的资料是由『已建立的资料库/var/lib/mlocate/』里面的资料所搜寻到的，所以不用直接在去硬碟当中存取资料！

​     有什么限制呢？就是因为他是经由资料库来搜寻的，而资料库的建立预设是在每天执行一次(每个distribution 都不同，CentOS 7.x 是每天更新资料库一次！)，所以当你新建立起来的档案， 却还在资料库更新之前搜寻该档案，那么locate 会告诉你『找不到！』！因为必须要更新资料库呀！

那能否手动更新资料库哪？当然可以啊！更新locate 资料库的方法非常简单，直接输入『 updatedb 』就可以了！updatedb 指令会去读取/etc/updatedb.conf 这个设定档的设定，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个资料库档案啰！因为updatedb 会去搜寻硬盘，所以当你执行updatedb 时，可能会等待数分钟的时间喔！

- updatedb：根据/etc/updatedb.conf 的设定去搜寻系统硬碟内的档名，并更新/var/lib/mlocate 内的资料库档案；
- locate：依据/var/lib/mlocate 内的资料库记载，找出使用者输入的关键字档名。

**find**

```
[root@study ~]# find [PATH] [option] [action] 
选项与参数：
1. 与时间有关的选项：共有-atime, -ctime 与-mtime ，以-mtime 说明
   -mtime n ：n 为数字，意义为在n 天之前的『一天之内』被更动过内容的档案；
   -mtime +n ：列出在n 天之前(不含n 天本身)被更动过内容的档案档名；
   -mtime -n ：列出在n 天之内(含n 天本身)被更动过内容的档案档名。
   -newer file ：file 为一个存在的档案，列出比file 还要新的档案档名

范例一：将过去系统上面24小时内有更动过内容(mtime)的档案列出 
[root@study ~]# find / -mtime 0 
#那个0是重点！0代表目前的时间，所以，从现在开始到24小时前，
# 有变动过内容的档案都会被列出来！那如果是三天前的24 小时内？
# find / -mtime 3 有变动过的档案都被列出的意思！

范例二：寻找/etc底下的档案，如果档案日期比/etc/passwd新就列出 
[root@study ~]# find /etc -newer /etc/passwd 
# -newer用在分辨两个档案之间的新旧关系是很有用的！
```

知道atime, ctime与mtime的意义，如果你想要找出一天内被更动过的档案名称，可以使用上述范例一的作法。但如果我想要找出『4天内被更动过的档案档名』呢？那可以使用『 find /var -mtime -4』。那如果是『4天前的那一天』就用『 find /var -mtime 4』。有没有加上『+, -』差别很大喔！我们可以用简单的图示来说明一下：



![find 相关的时间参数意义](https://tva1.sinaimg.cn/large/007S8ZIlgy1gi5owqr6org309t035jr6.gif)

图6.5.1、find 相关的时间参数意义

图中最右边为目前的时间，越往左边则代表越早之前的时间轴啦。由图6.5.1 我们可以清楚的知道：

- +4代表大于等于5天前的档名：ex> find /var -mtime +4
- -4代表小于等于4天内的档案档名：ex> find /var -mtime -4
- 4则是代表4-5那一天的档案档名：ex> find /var -mtime 4

其他find 的用法：

```
选项与参数：
2. 与使用者或群组名称有关的参数：
   -uid n ：n 为数字，这个数字是使用者的帐号ID，亦即UID ，这个UID 是记录在
            /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。
   -gid n ：n 为数字，这个数字是群组名称的ID，亦即GID，这个GID 记录在
            /etc/group，相关的介绍我们会第四篇说明～
   -user name ：name 为使用者帐号名称喔！例如dmtsai
   -group name：name 为群组名称喔，例如users ；
   -nouser ：寻找档案的拥有者不存在/etc/passwd 的人！
   -nogroup ：寻找档案的拥有群组不存在于/etc/group 的档案！
                当你自行安装软体时，很可能该软体的属性当中并没有档案拥有者，
                这是可能的！在这个时候，就可以使用-nouser 与-nogroup 搜寻。

范例三：搜寻/home底下属于dmtsai的档案 
[root@study ~]# find /home -user dmtsai 
#这个东西也很有用的～当我们要找出任何一个使用者在系统当中的所有档案时，
# 就可以利用这个指令将属于某个使用者的所有档案都找出来喔！

范例四：搜寻系统中不属于任何人的档案 
[root@study ~]# find / -nouser 
#透过这个指令，可以轻易的就找出那些不太正常的档案。如果有找到不属于系统任何人的档案时，
# 不要太紧张，那有时候是正常的～尤其是你曾经以原始码自行编译软体时。
```

## 复习

一、让使用者能进入某目录成为『可工作目录』的基本权限为何：

- 可使用的指令：例如cd 等变换工作目录的指令；
- 目录所需权限：使用者对这个目录至少需要具有x的权限
- 额外需求：如果使用者想要在这个目录内利用ls 查阅档名，则使用者对此目录还需要r 的权限。

二、使用者在某个目录内读取一个档案的基本权限为何？

- 可使用的指令：例如本章谈到的cat, more, less等等
- 目录所需权限：使用者对这个目录至少需要具有x 权限；
- 档案所需权限：使用者对档案至少需要具有r的权限才行！

三、让使用者可以修改一个档案的基本权限为何？

- 可使用的指令：例如[nano](http://linux.vbird.org/linux_basic/0160startlinux.php#nano)或未来要介绍的[vi](http://linux.vbird.org/linux_basic/0310vi.php)编辑器等；
- 目录所需权限：使用者在该档案所在的目录至少要有x 权限；
- 档案所需权限：使用者对该档案至少要有r, w权限

四、让一个使用者可以建立一个档案的基本权限为何？

- 目录所需权限：使用者在该目录要具有w,x的权限，重点在w啦！

五、让使用者进入某目录并执行该目录下的某个指令之基本权限为何？

- 目录所需权限：使用者在该目录至少要有x 的权限；
- 档案所需权限：使用者在该档案至少需要有x 的权限

------

**其他的知识点**

- 绝对路径：『一定由根目录/ 写起』；相对路径：『不由/ 写起，而是由相对当前目录写起』
- 特殊目录有：., .., -, ~, ~account需要注意；
- 与目录相关的指令有：cd, mkdir, rmdir, pwd 等重要指令；
- rmdir 仅能删除空目录，要删除非空目录需使用『 rm -r 』指令；
- 使用者能使用的指令是依据PATH 变数所规定的目录去搜寻的；
- ls 可以检视档案的属性，尤其-d, -a, -l 等选项特别重要！
- 文件的复制、删除、移动可以分别使用：cp, rm , mv等指令来操作；
- 检查文件的内容(读档)可使用的指令包括有：cat, tac, nl, more, less, head, tail, od 等
- cat -n 与nl 均可显示行号，但预设的情况下，空白行会不会编号并不相同；
- touch 的目的在修改档案的时间参数，但亦可用来建立空档案；
- 一个文件记录的时间参数有三种，分别是access time(atime), status time (ctime), modification time(mtime)，ls 预设显示的是mtime。
- 除了传统的rwx权限之外，在Ext2/Ext3/Ext4/xfs档案系统中，还可以使用chattr与lsattr设定及观察隐藏属性。常见的包括只能新增资料的+a 与完全不能更动档案的+i 属性。
- 新建文件/目录时，新文件的预设权限使用umask 来规范。预设目录完全权限为drwxrwxrwx， 档案则为-rw-rw-rw-。
- 文件具有SUID的特殊权限时，代表当使用者执行此一binary程式时，在执行过程中使用者会暂时具有程式拥有者的权限
- 目录具有SGID的特殊权限时，代表使用者在这个目录底下新建的档案之群组都会与该目录的群组名称相同。
- 目录具有SBIT的特殊权限时，代表在该目录下使用者建立的档案只有自己与root能够删除！
- 观察档案的类型可以使用file 指令来观察；
- 搜寻指令的完整档名可用which 或type ，这两个指令都是透过PATH 变数来搜寻档名；
- 搜寻文件的完整档名可以使用whereis 找特定目录或locate 到资料库去搜寻，而不实际搜寻档案系统；
- 利用find 可以加入许多选项来直接查询档案系统，以获得自己想要知道的文件名；